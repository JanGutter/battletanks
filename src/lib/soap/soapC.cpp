/* soapC.cpp
   Generated by gSOAP 2.8.15 from ChallengeService.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include <soap/soapH.h>

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.15 2013-09-03 20:50:44 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__action:
		return soap_in_ns1__action(soap, NULL, NULL, "ns1:action");
	case SOAP_TYPE_ns1__direction:
		return soap_in_ns1__direction(soap, NULL, NULL, "ns1:direction");
	case SOAP_TYPE_ns1__state:
		return soap_in_ns1__state(soap, NULL, NULL, "ns1:state");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__NoBlameException:
		return soap_in_ns1__NoBlameException(soap, NULL, NULL, "ns1:NoBlameException");
	case SOAP_TYPE_ns1__EndOfGameException:
		return soap_in_ns1__EndOfGameException(soap, NULL, NULL, "ns1:EndOfGameException");
	case SOAP_TYPE_ns1__stateArray:
		return soap_in_ns1__stateArray(soap, NULL, NULL, "ns1:stateArray");
	case SOAP_TYPE_ns1__setActionsResponse:
		return soap_in_ns1__setActionsResponse(soap, NULL, NULL, "ns1:setActionsResponse");
	case SOAP_TYPE_ns1__setActions:
		return soap_in_ns1__setActions(soap, NULL, NULL, "ns1:setActions");
	case SOAP_TYPE_ns1__board:
		return soap_in_ns1__board(soap, NULL, NULL, "ns1:board");
	case SOAP_TYPE_ns1__loginResponse:
		return soap_in_ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_ns1__login:
		return soap_in_ns1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_ns1__delta:
		return soap_in_ns1__delta(soap, NULL, NULL, "ns1:delta");
	case SOAP_TYPE_ns1__setActionResponse:
		return soap_in_ns1__setActionResponse(soap, NULL, NULL, "ns1:setActionResponse");
	case SOAP_TYPE_ns1__setAction:
		return soap_in_ns1__setAction(soap, NULL, NULL, "ns1:setAction");
	case SOAP_TYPE_ns1__arrayList:
		return soap_in_ns1__arrayList(soap, NULL, NULL, "ns1:arrayList");
	case SOAP_TYPE_ns1__abstractList:
		return soap_in_ns1__abstractList(soap, NULL, NULL, "ns1:abstractList");
	case SOAP_TYPE_ns1__abstractCollection:
		return soap_in_ns1__abstractCollection(soap, NULL, NULL, "ns1:abstractCollection");
	case SOAP_TYPE_ns1__base:
		return soap_in_ns1__base(soap, NULL, NULL, "ns1:base");
	case SOAP_TYPE_ns1__player:
		return soap_in_ns1__player(soap, NULL, NULL, "ns1:player");
	case SOAP_TYPE_ns1__unit:
		return soap_in_ns1__unit(soap, NULL, NULL, "ns1:unit");
	case SOAP_TYPE_ns1__bullet:
		return soap_in_ns1__bullet(soap, NULL, NULL, "ns1:bullet");
	case SOAP_TYPE_ns1__unitEvent:
		return soap_in_ns1__unitEvent(soap, NULL, NULL, "ns1:unitEvent");
	case SOAP_TYPE_ns1__point:
		return soap_in_ns1__point(soap, NULL, NULL, "ns1:point");
	case SOAP_TYPE_ns1__blockEvent:
		return soap_in_ns1__blockEvent(soap, NULL, NULL, "ns1:blockEvent");
	case SOAP_TYPE_ns1__events:
		return soap_in_ns1__events(soap, NULL, NULL, "ns1:events");
	case SOAP_TYPE_ns1__game:
		return soap_in_ns1__game(soap, NULL, NULL, "ns1:game");
	case SOAP_TYPE_ns1__getStatusResponse:
		return soap_in_ns1__getStatusResponse(soap, NULL, NULL, "ns1:getStatusResponse");
	case SOAP_TYPE_ns1__getStatus:
		return soap_in_ns1__getStatus(soap, NULL, NULL, "ns1:getStatus");
	case SOAP_TYPE_PointerTons1__setActionsResponse:
		return soap_in_PointerTons1__setActionsResponse(soap, NULL, NULL, "ns1:setActionsResponse");
	case SOAP_TYPE_PointerTons1__setActions:
		return soap_in_PointerTons1__setActions(soap, NULL, NULL, "ns1:setActions");
	case SOAP_TYPE_PointerTons1__loginResponse:
		return soap_in_PointerTons1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_PointerTons1__login:
		return soap_in_PointerTons1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_PointerTons1__setActionResponse:
		return soap_in_PointerTons1__setActionResponse(soap, NULL, NULL, "ns1:setActionResponse");
	case SOAP_TYPE_PointerTons1__setAction:
		return soap_in_PointerTons1__setAction(soap, NULL, NULL, "ns1:setAction");
	case SOAP_TYPE_PointerTons1__getStatusResponse:
		return soap_in_PointerTons1__getStatusResponse(soap, NULL, NULL, "ns1:getStatusResponse");
	case SOAP_TYPE_PointerTons1__getStatus:
		return soap_in_PointerTons1__getStatus(soap, NULL, NULL, "ns1:getStatus");
	case SOAP_TYPE_PointerTons1__NoBlameException:
		return soap_in_PointerTons1__NoBlameException(soap, NULL, NULL, "ns1:NoBlameException");
	case SOAP_TYPE_PointerTons1__EndOfGameException:
		return soap_in_PointerTons1__EndOfGameException(soap, NULL, NULL, "ns1:EndOfGameException");
	case SOAP_TYPE_PointerTons1__stateArray:
		return soap_in_PointerTons1__stateArray(soap, NULL, NULL, "ns1:stateArray");
	case SOAP_TYPE_PointerTons1__board:
		return soap_in_PointerTons1__board(soap, NULL, NULL, "ns1:board");
	case SOAP_TYPE_PointerTons1__delta:
		return soap_in_PointerTons1__delta(soap, NULL, NULL, "ns1:delta");
	case SOAP_TYPE_PointerTons1__base:
		return soap_in_PointerTons1__base(soap, NULL, NULL, "ns1:base");
	case SOAP_TYPE_PointerTons1__action:
		return soap_in_PointerTons1__action(soap, NULL, NULL, "ns1:action");
	case SOAP_TYPE_PointerTons1__direction:
		return soap_in_PointerTons1__direction(soap, NULL, NULL, "ns1:direction");
	case SOAP_TYPE_PointerTons1__unit:
		return soap_in_PointerTons1__unit(soap, NULL, NULL, "ns1:unit");
	case SOAP_TYPE_PointerTons1__bullet:
		return soap_in_PointerTons1__bullet(soap, NULL, NULL, "ns1:bullet");
	case SOAP_TYPE_PointerTons1__point:
		return soap_in_PointerTons1__point(soap, NULL, NULL, "ns1:point");
	case SOAP_TYPE_PointerTons1__state:
		return soap_in_PointerTons1__state(soap, NULL, NULL, "ns1:state");
	case SOAP_TYPE_PointerTons1__unitEvent:
		return soap_in_PointerTons1__unitEvent(soap, NULL, NULL, "ns1:unitEvent");
	case SOAP_TYPE_PointerTons1__blockEvent:
		return soap_in_PointerTons1__blockEvent(soap, NULL, NULL, "ns1:blockEvent");
	case SOAP_TYPE_PointerTons1__player:
		return soap_in_PointerTons1__player(soap, NULL, NULL, "ns1:player");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__events:
		return soap_in_PointerTons1__events(soap, NULL, NULL, "ns1:events");
	case SOAP_TYPE_PointerTons1__game:
		return soap_in_PointerTons1__game(soap, NULL, NULL, "ns1:game");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NoBlameException"))
		{	*type = SOAP_TYPE_ns1__NoBlameException;
			return soap_in_ns1__NoBlameException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndOfGameException"))
		{	*type = SOAP_TYPE_ns1__EndOfGameException;
			return soap_in_ns1__EndOfGameException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:stateArray"))
		{	*type = SOAP_TYPE_ns1__stateArray;
			return soap_in_ns1__stateArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setActionsResponse"))
		{	*type = SOAP_TYPE_ns1__setActionsResponse;
			return soap_in_ns1__setActionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setActions"))
		{	*type = SOAP_TYPE_ns1__setActions;
			return soap_in_ns1__setActions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:board"))
		{	*type = SOAP_TYPE_ns1__board;
			return soap_in_ns1__board(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE_ns1__loginResponse;
			return soap_in_ns1__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:login"))
		{	*type = SOAP_TYPE_ns1__login;
			return soap_in_ns1__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:delta"))
		{	*type = SOAP_TYPE_ns1__delta;
			return soap_in_ns1__delta(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setActionResponse"))
		{	*type = SOAP_TYPE_ns1__setActionResponse;
			return soap_in_ns1__setActionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAction"))
		{	*type = SOAP_TYPE_ns1__setAction;
			return soap_in_ns1__setAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:arrayList"))
		{	*type = SOAP_TYPE_ns1__arrayList;
			return soap_in_ns1__arrayList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:abstractList"))
		{	*type = SOAP_TYPE_ns1__abstractList;
			return soap_in_ns1__abstractList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:abstractCollection"))
		{	*type = SOAP_TYPE_ns1__abstractCollection;
			return soap_in_ns1__abstractCollection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:base"))
		{	*type = SOAP_TYPE_ns1__base;
			return soap_in_ns1__base(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:player"))
		{	*type = SOAP_TYPE_ns1__player;
			return soap_in_ns1__player(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unit"))
		{	*type = SOAP_TYPE_ns1__unit;
			return soap_in_ns1__unit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bullet"))
		{	*type = SOAP_TYPE_ns1__bullet;
			return soap_in_ns1__bullet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unitEvent"))
		{	*type = SOAP_TYPE_ns1__unitEvent;
			return soap_in_ns1__unitEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:point"))
		{	*type = SOAP_TYPE_ns1__point;
			return soap_in_ns1__point(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:blockEvent"))
		{	*type = SOAP_TYPE_ns1__blockEvent;
			return soap_in_ns1__blockEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:events"))
		{	*type = SOAP_TYPE_ns1__events;
			return soap_in_ns1__events(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:game"))
		{	*type = SOAP_TYPE_ns1__game;
			return soap_in_ns1__game(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStatusResponse"))
		{	*type = SOAP_TYPE_ns1__getStatusResponse;
			return soap_in_ns1__getStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStatus"))
		{	*type = SOAP_TYPE_ns1__getStatus;
			return soap_in_ns1__getStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:action"))
		{	*type = SOAP_TYPE_ns1__action;
			return soap_in_ns1__action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:direction"))
		{	*type = SOAP_TYPE_ns1__direction;
			return soap_in_ns1__direction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:state"))
		{	*type = SOAP_TYPE_ns1__state;
			return soap_in_ns1__state(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns1__action:
		return soap_out_ns1__action(soap, tag, id, (const enum ns1__action *)ptr, "ns1:action");
	case SOAP_TYPE_ns1__direction:
		return soap_out_ns1__direction(soap, tag, id, (const enum ns1__direction *)ptr, "ns1:direction");
	case SOAP_TYPE_ns1__state:
		return soap_out_ns1__state(soap, tag, id, (const enum ns1__state *)ptr, "ns1:state");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__NoBlameException:
		return ((ns1__NoBlameException *)ptr)->soap_out(soap, tag, id, "ns1:NoBlameException");
	case SOAP_TYPE_ns1__EndOfGameException:
		return ((ns1__EndOfGameException *)ptr)->soap_out(soap, tag, id, "ns1:EndOfGameException");
	case SOAP_TYPE_ns1__stateArray:
		return ((ns1__stateArray *)ptr)->soap_out(soap, tag, id, "ns1:stateArray");
	case SOAP_TYPE_ns1__setActionsResponse:
		return ((ns1__setActionsResponse *)ptr)->soap_out(soap, tag, id, "ns1:setActionsResponse");
	case SOAP_TYPE_ns1__setActions:
		return ((ns1__setActions *)ptr)->soap_out(soap, tag, id, "ns1:setActions");
	case SOAP_TYPE_ns1__board:
		return ((ns1__board *)ptr)->soap_out(soap, tag, id, "ns1:board");
	case SOAP_TYPE_ns1__loginResponse:
		return ((ns1__loginResponse *)ptr)->soap_out(soap, tag, id, "ns1:loginResponse");
	case SOAP_TYPE_ns1__login:
		return ((ns1__login *)ptr)->soap_out(soap, tag, id, "ns1:login");
	case SOAP_TYPE_ns1__delta:
		return ((ns1__delta *)ptr)->soap_out(soap, tag, id, "ns1:delta");
	case SOAP_TYPE_ns1__setActionResponse:
		return ((ns1__setActionResponse *)ptr)->soap_out(soap, tag, id, "ns1:setActionResponse");
	case SOAP_TYPE_ns1__setAction:
		return ((ns1__setAction *)ptr)->soap_out(soap, tag, id, "ns1:setAction");
	case SOAP_TYPE_ns1__arrayList:
		return ((ns1__arrayList *)ptr)->soap_out(soap, tag, id, "ns1:arrayList");
	case SOAP_TYPE_ns1__abstractList:
		return ((ns1__abstractList *)ptr)->soap_out(soap, tag, id, "ns1:abstractList");
	case SOAP_TYPE_ns1__abstractCollection:
		return ((ns1__abstractCollection *)ptr)->soap_out(soap, tag, id, "ns1:abstractCollection");
	case SOAP_TYPE_ns1__base:
		return ((ns1__base *)ptr)->soap_out(soap, tag, id, "ns1:base");
	case SOAP_TYPE_ns1__player:
		return ((ns1__player *)ptr)->soap_out(soap, tag, id, "ns1:player");
	case SOAP_TYPE_ns1__unit:
		return ((ns1__unit *)ptr)->soap_out(soap, tag, id, "ns1:unit");
	case SOAP_TYPE_ns1__bullet:
		return ((ns1__bullet *)ptr)->soap_out(soap, tag, id, "ns1:bullet");
	case SOAP_TYPE_ns1__unitEvent:
		return ((ns1__unitEvent *)ptr)->soap_out(soap, tag, id, "ns1:unitEvent");
	case SOAP_TYPE_ns1__point:
		return ((ns1__point *)ptr)->soap_out(soap, tag, id, "ns1:point");
	case SOAP_TYPE_ns1__blockEvent:
		return ((ns1__blockEvent *)ptr)->soap_out(soap, tag, id, "ns1:blockEvent");
	case SOAP_TYPE_ns1__events:
		return ((ns1__events *)ptr)->soap_out(soap, tag, id, "ns1:events");
	case SOAP_TYPE_ns1__game:
		return ((ns1__game *)ptr)->soap_out(soap, tag, id, "ns1:game");
	case SOAP_TYPE_ns1__getStatusResponse:
		return ((ns1__getStatusResponse *)ptr)->soap_out(soap, tag, id, "ns1:getStatusResponse");
	case SOAP_TYPE_ns1__getStatus:
		return ((ns1__getStatus *)ptr)->soap_out(soap, tag, id, "ns1:getStatus");
	case SOAP_TYPE_PointerTons1__setActionsResponse:
		return soap_out_PointerTons1__setActionsResponse(soap, tag, id, (ns1__setActionsResponse *const*)ptr, "ns1:setActionsResponse");
	case SOAP_TYPE_PointerTons1__setActions:
		return soap_out_PointerTons1__setActions(soap, tag, id, (ns1__setActions *const*)ptr, "ns1:setActions");
	case SOAP_TYPE_PointerTons1__loginResponse:
		return soap_out_PointerTons1__loginResponse(soap, tag, id, (ns1__loginResponse *const*)ptr, "ns1:loginResponse");
	case SOAP_TYPE_PointerTons1__login:
		return soap_out_PointerTons1__login(soap, tag, id, (ns1__login *const*)ptr, "ns1:login");
	case SOAP_TYPE_PointerTons1__setActionResponse:
		return soap_out_PointerTons1__setActionResponse(soap, tag, id, (ns1__setActionResponse *const*)ptr, "ns1:setActionResponse");
	case SOAP_TYPE_PointerTons1__setAction:
		return soap_out_PointerTons1__setAction(soap, tag, id, (ns1__setAction *const*)ptr, "ns1:setAction");
	case SOAP_TYPE_PointerTons1__getStatusResponse:
		return soap_out_PointerTons1__getStatusResponse(soap, tag, id, (ns1__getStatusResponse *const*)ptr, "ns1:getStatusResponse");
	case SOAP_TYPE_PointerTons1__getStatus:
		return soap_out_PointerTons1__getStatus(soap, tag, id, (ns1__getStatus *const*)ptr, "ns1:getStatus");
	case SOAP_TYPE_PointerTons1__NoBlameException:
		return soap_out_PointerTons1__NoBlameException(soap, tag, id, (ns1__NoBlameException *const*)ptr, "ns1:NoBlameException");
	case SOAP_TYPE_PointerTons1__EndOfGameException:
		return soap_out_PointerTons1__EndOfGameException(soap, tag, id, (ns1__EndOfGameException *const*)ptr, "ns1:EndOfGameException");
	case SOAP_TYPE_PointerTons1__stateArray:
		return soap_out_PointerTons1__stateArray(soap, tag, id, (ns1__stateArray *const*)ptr, "ns1:stateArray");
	case SOAP_TYPE_PointerTons1__board:
		return soap_out_PointerTons1__board(soap, tag, id, (ns1__board *const*)ptr, "ns1:board");
	case SOAP_TYPE_PointerTons1__delta:
		return soap_out_PointerTons1__delta(soap, tag, id, (ns1__delta *const*)ptr, "ns1:delta");
	case SOAP_TYPE_PointerTons1__base:
		return soap_out_PointerTons1__base(soap, tag, id, (ns1__base *const*)ptr, "ns1:base");
	case SOAP_TYPE_PointerTons1__action:
		return soap_out_PointerTons1__action(soap, tag, id, (enum ns1__action *const*)ptr, "ns1:action");
	case SOAP_TYPE_PointerTons1__direction:
		return soap_out_PointerTons1__direction(soap, tag, id, (enum ns1__direction *const*)ptr, "ns1:direction");
	case SOAP_TYPE_PointerTons1__unit:
		return soap_out_PointerTons1__unit(soap, tag, id, (ns1__unit *const*)ptr, "ns1:unit");
	case SOAP_TYPE_PointerTons1__bullet:
		return soap_out_PointerTons1__bullet(soap, tag, id, (ns1__bullet *const*)ptr, "ns1:bullet");
	case SOAP_TYPE_PointerTons1__point:
		return soap_out_PointerTons1__point(soap, tag, id, (ns1__point *const*)ptr, "ns1:point");
	case SOAP_TYPE_PointerTons1__state:
		return soap_out_PointerTons1__state(soap, tag, id, (enum ns1__state *const*)ptr, "ns1:state");
	case SOAP_TYPE_PointerTons1__unitEvent:
		return soap_out_PointerTons1__unitEvent(soap, tag, id, (ns1__unitEvent *const*)ptr, "ns1:unitEvent");
	case SOAP_TYPE_PointerTons1__blockEvent:
		return soap_out_PointerTons1__blockEvent(soap, tag, id, (ns1__blockEvent *const*)ptr, "ns1:blockEvent");
	case SOAP_TYPE_PointerTons1__player:
		return soap_out_PointerTons1__player(soap, tag, id, (ns1__player *const*)ptr, "ns1:player");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__events:
		return soap_out_PointerTons1__events(soap, tag, id, (ns1__events *const*)ptr, "ns1:events");
	case SOAP_TYPE_PointerTons1__game:
		return soap_out_PointerTons1__game(soap, tag, id, (ns1__game *const*)ptr, "ns1:game");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__NoBlameException:
		((ns1__NoBlameException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EndOfGameException:
		((ns1__EndOfGameException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__stateArray:
		((ns1__stateArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setActionsResponse:
		((ns1__setActionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setActions:
		((ns1__setActions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__board:
		((ns1__board *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loginResponse:
		((ns1__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__login:
		((ns1__login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__delta:
		((ns1__delta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setActionResponse:
		((ns1__setActionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setAction:
		((ns1__setAction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__arrayList:
		((ns1__arrayList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__abstractList:
		((ns1__abstractList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__abstractCollection:
		((ns1__abstractCollection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__base:
		((ns1__base *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__player:
		((ns1__player *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__unit:
		((ns1__unit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__bullet:
		((ns1__bullet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__unitEvent:
		((ns1__unitEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__point:
		((ns1__point *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__blockEvent:
		((ns1__blockEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__events:
		((ns1__events *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__game:
		((ns1__game *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getStatusResponse:
		((ns1__getStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getStatus:
		((ns1__getStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__setActions:
		soap_serialize___ns1__setActions(soap, (const struct __ns1__setActions *)ptr);
		break;
	case SOAP_TYPE___ns1__login:
		soap_serialize___ns1__login(soap, (const struct __ns1__login *)ptr);
		break;
	case SOAP_TYPE___ns1__setAction:
		soap_serialize___ns1__setAction(soap, (const struct __ns1__setAction *)ptr);
		break;
	case SOAP_TYPE___ns1__getStatus:
		soap_serialize___ns1__getStatus(soap, (const struct __ns1__getStatus *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setActionsResponse:
		soap_serialize_PointerTons1__setActionsResponse(soap, (ns1__setActionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setActions:
		soap_serialize_PointerTons1__setActions(soap, (ns1__setActions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__loginResponse:
		soap_serialize_PointerTons1__loginResponse(soap, (ns1__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__login:
		soap_serialize_PointerTons1__login(soap, (ns1__login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setActionResponse:
		soap_serialize_PointerTons1__setActionResponse(soap, (ns1__setActionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setAction:
		soap_serialize_PointerTons1__setAction(soap, (ns1__setAction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getStatusResponse:
		soap_serialize_PointerTons1__getStatusResponse(soap, (ns1__getStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getStatus:
		soap_serialize_PointerTons1__getStatus(soap, (ns1__getStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NoBlameException:
		soap_serialize_PointerTons1__NoBlameException(soap, (ns1__NoBlameException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EndOfGameException:
		soap_serialize_PointerTons1__EndOfGameException(soap, (ns1__EndOfGameException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__stateArray:
		soap_serialize_PointerTons1__stateArray(soap, (ns1__stateArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__board:
		soap_serialize_PointerTons1__board(soap, (ns1__board *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__delta:
		soap_serialize_PointerTons1__delta(soap, (ns1__delta *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__base:
		soap_serialize_PointerTons1__base(soap, (ns1__base *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__action:
		soap_serialize_PointerTons1__action(soap, (enum ns1__action *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__direction:
		soap_serialize_PointerTons1__direction(soap, (enum ns1__direction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__unit:
		soap_serialize_PointerTons1__unit(soap, (ns1__unit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__bullet:
		soap_serialize_PointerTons1__bullet(soap, (ns1__bullet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__point:
		soap_serialize_PointerTons1__point(soap, (ns1__point *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__state:
		soap_serialize_PointerTons1__state(soap, (enum ns1__state *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__unitEvent:
		soap_serialize_PointerTons1__unitEvent(soap, (ns1__unitEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__blockEvent:
		soap_serialize_PointerTons1__blockEvent(soap, (ns1__blockEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__player:
		soap_serialize_PointerTons1__player(soap, (ns1__player *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__events:
		soap_serialize_PointerTons1__events(soap, (ns1__events *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__game:
		soap_serialize_PointerTons1__game(soap, (ns1__game *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__getStatus:
		return (void*)soap_instantiate_ns1__getStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStatusResponse:
		return (void*)soap_instantiate_ns1__getStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__game:
		return (void*)soap_instantiate_ns1__game(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__events:
		return (void*)soap_instantiate_ns1__events(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__blockEvent:
		return (void*)soap_instantiate_ns1__blockEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__point:
		return (void*)soap_instantiate_ns1__point(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unitEvent:
		return (void*)soap_instantiate_ns1__unitEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bullet:
		return (void*)soap_instantiate_ns1__bullet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unit:
		return (void*)soap_instantiate_ns1__unit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__player:
		return (void*)soap_instantiate_ns1__player(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__base:
		return (void*)soap_instantiate_ns1__base(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__abstractCollection:
		return (void*)soap_instantiate_ns1__abstractCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setAction:
		return (void*)soap_instantiate_ns1__setAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setActionResponse:
		return (void*)soap_instantiate_ns1__setActionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__delta:
		return (void*)soap_instantiate_ns1__delta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__login:
		return (void*)soap_instantiate_ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loginResponse:
		return (void*)soap_instantiate_ns1__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__board:
		return (void*)soap_instantiate_ns1__board(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setActions:
		return (void*)soap_instantiate_ns1__setActions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setActionsResponse:
		return (void*)soap_instantiate_ns1__setActionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__stateArray:
		return (void*)soap_instantiate_ns1__stateArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EndOfGameException:
		return (void*)soap_instantiate_ns1__EndOfGameException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NoBlameException:
		return (void*)soap_instantiate_ns1__NoBlameException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__abstractList:
		return (void*)soap_instantiate_ns1__abstractList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__arrayList:
		return (void*)soap_instantiate_ns1__arrayList(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__getStatus:
		return (void*)soap_instantiate___ns1__getStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setAction:
		return (void*)soap_instantiate___ns1__setAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__login:
		return (void*)soap_instantiate___ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setActions:
		return (void*)soap_instantiate___ns1__setActions(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfns1__state:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__state(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__stateArray:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__stateArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__unit:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__unit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__bullet:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__bullet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__unitEvent:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__unitEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__blockEvent:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__blockEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__player:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__player(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__getStatus:
		if (p->size < 0)
			SOAP_DELETE((ns1__getStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__game:
		if (p->size < 0)
			SOAP_DELETE((ns1__game*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__game*)p->ptr);
		break;
	case SOAP_TYPE_ns1__events:
		if (p->size < 0)
			SOAP_DELETE((ns1__events*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__events*)p->ptr);
		break;
	case SOAP_TYPE_ns1__blockEvent:
		if (p->size < 0)
			SOAP_DELETE((ns1__blockEvent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__blockEvent*)p->ptr);
		break;
	case SOAP_TYPE_ns1__point:
		if (p->size < 0)
			SOAP_DELETE((ns1__point*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__point*)p->ptr);
		break;
	case SOAP_TYPE_ns1__unitEvent:
		if (p->size < 0)
			SOAP_DELETE((ns1__unitEvent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__unitEvent*)p->ptr);
		break;
	case SOAP_TYPE_ns1__bullet:
		if (p->size < 0)
			SOAP_DELETE((ns1__bullet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__bullet*)p->ptr);
		break;
	case SOAP_TYPE_ns1__unit:
		if (p->size < 0)
			SOAP_DELETE((ns1__unit*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__unit*)p->ptr);
		break;
	case SOAP_TYPE_ns1__player:
		if (p->size < 0)
			SOAP_DELETE((ns1__player*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__player*)p->ptr);
		break;
	case SOAP_TYPE_ns1__base:
		if (p->size < 0)
			SOAP_DELETE((ns1__base*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__base*)p->ptr);
		break;
	case SOAP_TYPE_ns1__abstractCollection:
		if (p->size < 0)
			SOAP_DELETE((ns1__abstractCollection*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__abstractCollection*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setAction:
		if (p->size < 0)
			SOAP_DELETE((ns1__setAction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__setAction*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setActionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__setActionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__setActionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__delta:
		if (p->size < 0)
			SOAP_DELETE((ns1__delta*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__delta*)p->ptr);
		break;
	case SOAP_TYPE_ns1__login:
		if (p->size < 0)
			SOAP_DELETE((ns1__login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__login*)p->ptr);
		break;
	case SOAP_TYPE_ns1__loginResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__loginResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__loginResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__board:
		if (p->size < 0)
			SOAP_DELETE((ns1__board*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__board*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setActions:
		if (p->size < 0)
			SOAP_DELETE((ns1__setActions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__setActions*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setActionsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__setActionsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__setActionsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__stateArray:
		if (p->size < 0)
			SOAP_DELETE((ns1__stateArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__stateArray*)p->ptr);
		break;
	case SOAP_TYPE_ns1__EndOfGameException:
		if (p->size < 0)
			SOAP_DELETE((ns1__EndOfGameException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__EndOfGameException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__NoBlameException:
		if (p->size < 0)
			SOAP_DELETE((ns1__NoBlameException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__NoBlameException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__abstractList:
		if (p->size < 0)
			SOAP_DELETE((ns1__abstractList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__abstractList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__arrayList:
		if (p->size < 0)
			SOAP_DELETE((ns1__arrayList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__arrayList*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___ns1__getStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setAction:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setAction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setAction*)p->ptr);
		break;
	case SOAP_TYPE___ns1__login:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__login*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setActions:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setActions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setActions*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfns1__state:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns1__state >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns1__state >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__stateArray:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__stateArray * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__stateArray * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__unit:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__unit * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__unit * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__bullet:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__bullet * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__bullet * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__unitEvent:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__unitEvent * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__unitEvent * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__blockEvent:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__blockEvent * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__blockEvent * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__player:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__player * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__player * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfns1__state:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns1__state >*)p)[len] = *(enum ns1__state *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__stateArray:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__stateArray * >*)p)[len] = *(ns1__stateArray **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__unit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__unit * >*)p)[len] = *(ns1__unit **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__bullet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__bullet * >*)p)[len] = *(ns1__bullet **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__unitEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__unitEvent * >*)p)[len] = *(ns1__unitEvent **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__blockEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__blockEvent * >*)p)[len] = *(ns1__blockEvent **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__player:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__player * >*)p)[len] = *(ns1__player **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__action(struct soap *soap, enum ns1__action *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__action
	*a = SOAP_DEFAULT_ns1__action;
#else
	*a = (enum ns1__action)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__action[] =
{	{ (long)ns1__action__NONE, "NONE" },
	{ (long)ns1__action__UP, "UP" },
	{ (long)ns1__action__DOWN, "DOWN" },
	{ (long)ns1__action__LEFT, "LEFT" },
	{ (long)ns1__action__RIGHT, "RIGHT" },
	{ (long)ns1__action__FIRE, "FIRE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__action2s(struct soap *soap, enum ns1__action n)
{	const char *s = soap_code_str(soap_codes_ns1__action, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__action(struct soap *soap, const char *tag, int id, const enum ns1__action *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__action), type) || soap_send(soap, soap_ns1__action2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__action(struct soap *soap, const char *s, enum ns1__action *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__action, s);
	if (map)
		*a = (enum ns1__action)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__action)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__action * SOAP_FMAC4 soap_in_ns1__action(struct soap *soap, const char *tag, enum ns1__action *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__action *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__action, sizeof(enum ns1__action), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__action(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__action *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__action, 0, sizeof(enum ns1__action), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__action(struct soap *soap, const enum ns1__action *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__action);
	if (soap_out_ns1__action(soap, tag?tag:"ns1:action", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__action * SOAP_FMAC4 soap_get_ns1__action(struct soap *soap, enum ns1__action *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__action(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__direction(struct soap *soap, enum ns1__direction *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__direction
	*a = SOAP_DEFAULT_ns1__direction;
#else
	*a = (enum ns1__direction)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__direction[] =
{	{ (long)ns1__direction__NONE, "NONE" },
	{ (long)ns1__direction__UP, "UP" },
	{ (long)ns1__direction__DOWN, "DOWN" },
	{ (long)ns1__direction__LEFT, "LEFT" },
	{ (long)ns1__direction__RIGHT, "RIGHT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__direction2s(struct soap *soap, enum ns1__direction n)
{	const char *s = soap_code_str(soap_codes_ns1__direction, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__direction(struct soap *soap, const char *tag, int id, const enum ns1__direction *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__direction), type) || soap_send(soap, soap_ns1__direction2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__direction(struct soap *soap, const char *s, enum ns1__direction *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__direction, s);
	if (map)
		*a = (enum ns1__direction)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__direction)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__direction * SOAP_FMAC4 soap_in_ns1__direction(struct soap *soap, const char *tag, enum ns1__direction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__direction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__direction, sizeof(enum ns1__direction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__direction(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__direction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__direction, 0, sizeof(enum ns1__direction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__direction(struct soap *soap, const enum ns1__direction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__direction);
	if (soap_out_ns1__direction(soap, tag?tag:"ns1:direction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__direction * SOAP_FMAC4 soap_get_ns1__direction(struct soap *soap, enum ns1__direction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__direction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__state(struct soap *soap, enum ns1__state *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__state
	*a = SOAP_DEFAULT_ns1__state;
#else
	*a = (enum ns1__state)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__state[] =
{	{ (long)ns1__state__FULL, "FULL" },
	{ (long)ns1__state__EMPTY, "EMPTY" },
	{ (long)ns1__state__OUT_USCOREOF_USCOREBOUNDS, "OUT_OF_BOUNDS" },
	{ (long)ns1__state__NONE, "NONE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__state2s(struct soap *soap, enum ns1__state n)
{	const char *s = soap_code_str(soap_codes_ns1__state, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__state(struct soap *soap, const char *tag, int id, const enum ns1__state *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__state), type) || soap_send(soap, soap_ns1__state2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__state(struct soap *soap, const char *s, enum ns1__state *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__state, s);
	if (map)
		*a = (enum ns1__state)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__state)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__state * SOAP_FMAC4 soap_in_ns1__state(struct soap *soap, const char *tag, enum ns1__state *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__state *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__state, sizeof(enum ns1__state), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__state(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__state *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__state, 0, sizeof(enum ns1__state), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__state(struct soap *soap, const enum ns1__state *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__state);
	if (soap_out_ns1__state(soap, tag?tag:"ns1:state", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__state * SOAP_FMAC4 soap_get_ns1__state(struct soap *soap, enum ns1__state *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__state(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns1__NoBlameException::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__NoBlameException::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__NoBlameException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NoBlameException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NoBlameException(struct soap *soap, const char *tag, int id, const ns1__NoBlameException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NoBlameException), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__NoBlameException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NoBlameException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NoBlameException * SOAP_FMAC4 soap_in_ns1__NoBlameException(struct soap *soap, const char *tag, ns1__NoBlameException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NoBlameException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NoBlameException, sizeof(ns1__NoBlameException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__NoBlameException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__NoBlameException *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NoBlameException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NoBlameException, 0, sizeof(ns1__NoBlameException), 0, soap_copy_ns1__NoBlameException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__NoBlameException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__NoBlameException);
	if (this->soap_out(soap, tag?tag:"ns1:NoBlameException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NoBlameException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NoBlameException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NoBlameException * SOAP_FMAC4 soap_get_ns1__NoBlameException(struct soap *soap, ns1__NoBlameException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NoBlameException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__NoBlameException * SOAP_FMAC2 soap_instantiate_ns1__NoBlameException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NoBlameException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__NoBlameException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoBlameException);
		if (size)
			*size = sizeof(ns1__NoBlameException);
		((ns1__NoBlameException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__NoBlameException, n);
		if (size)
			*size = n * sizeof(ns1__NoBlameException);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__NoBlameException*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__NoBlameException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__NoBlameException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__NoBlameException %p -> %p\n", q, p));
	*(ns1__NoBlameException*)p = *(ns1__NoBlameException*)q;
}

void ns1__EndOfGameException::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__EndOfGameException::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__EndOfGameException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EndOfGameException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EndOfGameException(struct soap *soap, const char *tag, int id, const ns1__EndOfGameException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EndOfGameException), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__EndOfGameException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EndOfGameException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EndOfGameException * SOAP_FMAC4 soap_in_ns1__EndOfGameException(struct soap *soap, const char *tag, ns1__EndOfGameException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EndOfGameException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EndOfGameException, sizeof(ns1__EndOfGameException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EndOfGameException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EndOfGameException *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EndOfGameException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EndOfGameException, 0, sizeof(ns1__EndOfGameException), 0, soap_copy_ns1__EndOfGameException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__EndOfGameException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EndOfGameException);
	if (this->soap_out(soap, tag?tag:"ns1:EndOfGameException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EndOfGameException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EndOfGameException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EndOfGameException * SOAP_FMAC4 soap_get_ns1__EndOfGameException(struct soap *soap, ns1__EndOfGameException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EndOfGameException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__EndOfGameException * SOAP_FMAC2 soap_instantiate_ns1__EndOfGameException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EndOfGameException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EndOfGameException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__EndOfGameException);
		if (size)
			*size = sizeof(ns1__EndOfGameException);
		((ns1__EndOfGameException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__EndOfGameException, n);
		if (size)
			*size = n * sizeof(ns1__EndOfGameException);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__EndOfGameException*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__EndOfGameException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EndOfGameException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EndOfGameException %p -> %p\n", q, p));
	*(ns1__EndOfGameException*)p = *(ns1__EndOfGameException*)q;
}

void ns1__stateArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns1__state(soap, &this->ns1__stateArray::item);
	/* transient soap skipped */
}

void ns1__stateArray::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfns1__state(soap, &this->ns1__stateArray::item);
	/* transient soap skipped */
#endif
}

int ns1__stateArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__stateArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__stateArray(struct soap *soap, const char *tag, int id, const ns1__stateArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__stateArray), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__state(soap, "item", -1, &(a->ns1__stateArray::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__stateArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__stateArray(soap, tag, this, type);
}

SOAP_FMAC3 ns1__stateArray * SOAP_FMAC4 soap_in_ns1__stateArray(struct soap *soap, const char *tag, ns1__stateArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__stateArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__stateArray, sizeof(ns1__stateArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__stateArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__stateArray *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__state(soap, "item", &(a->ns1__stateArray::item), "ns1:state"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__stateArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__stateArray, 0, sizeof(ns1__stateArray), 0, soap_copy_ns1__stateArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__stateArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__stateArray);
	if (this->soap_out(soap, tag?tag:"ns1:stateArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__stateArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__stateArray(soap, this, tag, type);
}

SOAP_FMAC3 ns1__stateArray * SOAP_FMAC4 soap_get_ns1__stateArray(struct soap *soap, ns1__stateArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__stateArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__stateArray * SOAP_FMAC2 soap_instantiate_ns1__stateArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__stateArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__stateArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__stateArray);
		if (size)
			*size = sizeof(ns1__stateArray);
		((ns1__stateArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__stateArray, n);
		if (size)
			*size = n * sizeof(ns1__stateArray);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__stateArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__stateArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__stateArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__stateArray %p -> %p\n", q, p));
	*(ns1__stateArray*)p = *(ns1__stateArray*)q;
}

void ns1__setActionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__setActionsResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__setActionsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__delta(soap, &this->ns1__setActionsResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__setActionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setActionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setActionsResponse(struct soap *soap, const char *tag, int id, const ns1__setActionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setActionsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__delta(soap, "return", -1, &(a->ns1__setActionsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setActionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setActionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setActionsResponse * SOAP_FMAC4 soap_in_ns1__setActionsResponse(struct soap *soap, const char *tag, ns1__setActionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setActionsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setActionsResponse, sizeof(ns1__setActionsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setActionsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setActionsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__delta(soap, "return", &(a->ns1__setActionsResponse::return_), "ns1:delta"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setActionsResponse, 0, sizeof(ns1__setActionsResponse), 0, soap_copy_ns1__setActionsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__setActionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setActionsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:setActionsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__setActionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setActionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setActionsResponse * SOAP_FMAC4 soap_get_ns1__setActionsResponse(struct soap *soap, ns1__setActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__setActionsResponse * SOAP_FMAC2 soap_instantiate_ns1__setActionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setActionsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setActionsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__setActionsResponse);
		if (size)
			*size = sizeof(ns1__setActionsResponse);
		((ns1__setActionsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__setActionsResponse, n);
		if (size)
			*size = n * sizeof(ns1__setActionsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__setActionsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__setActionsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setActionsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setActionsResponse %p -> %p\n", q, p));
	*(ns1__setActionsResponse*)p = *(ns1__setActionsResponse*)q;
}

void ns1__setActions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__setActions::arg0 = NULL;
	this->ns1__setActions::arg1 = NULL;
	/* transient soap skipped */
}

void ns1__setActions::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__action(soap, &this->ns1__setActions::arg0);
	soap_serialize_PointerTons1__action(soap, &this->ns1__setActions::arg1);
	/* transient soap skipped */
#endif
}

int ns1__setActions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setActions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setActions(struct soap *soap, const char *tag, int id, const ns1__setActions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setActions), type))
		return soap->error;
	if (soap_out_PointerTons1__action(soap, "arg0", -1, &(a->ns1__setActions::arg0), ""))
		return soap->error;
	if (soap_out_PointerTons1__action(soap, "arg1", -1, &(a->ns1__setActions::arg1), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setActions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setActions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setActions * SOAP_FMAC4 soap_in_ns1__setActions(struct soap *soap, const char *tag, ns1__setActions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setActions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setActions, sizeof(ns1__setActions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setActions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setActions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__action(soap, "arg0", &(a->ns1__setActions::arg0), "ns1:action"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__action(soap, "arg1", &(a->ns1__setActions::arg1), "ns1:action"))
				{	soap_flag_arg11--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setActions, 0, sizeof(ns1__setActions), 0, soap_copy_ns1__setActions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__setActions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setActions);
	if (this->soap_out(soap, tag?tag:"ns1:setActions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__setActions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setActions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setActions * SOAP_FMAC4 soap_get_ns1__setActions(struct soap *soap, ns1__setActions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__setActions * SOAP_FMAC2 soap_instantiate_ns1__setActions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setActions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setActions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__setActions);
		if (size)
			*size = sizeof(ns1__setActions);
		((ns1__setActions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__setActions, n);
		if (size)
			*size = n * sizeof(ns1__setActions);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__setActions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__setActions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setActions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setActions %p -> %p\n", q, p));
	*(ns1__setActions*)p = *(ns1__setActions*)q;
}

void ns1__board::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__board::endGamePoint);
	soap_default_std__vectorTemplateOfPointerTons1__stateArray(soap, &this->ns1__board::states);
	/* transient soap skipped */
}

void ns1__board::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__stateArray(soap, &this->ns1__board::states);
	/* transient soap skipped */
#endif
}

int ns1__board::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__board(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__board(struct soap *soap, const char *tag, int id, const ns1__board *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__board), type))
		return soap->error;
	if (soap_out_int(soap, "endGamePoint", -1, &(a->ns1__board::endGamePoint), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__stateArray(soap, "states", -1, &(a->ns1__board::states), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__board::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__board(soap, tag, this, type);
}

SOAP_FMAC3 ns1__board * SOAP_FMAC4 soap_in_ns1__board(struct soap *soap, const char *tag, ns1__board *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__board *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__board, sizeof(ns1__board), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__board)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__board *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_endGamePoint1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_endGamePoint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "endGamePoint", &(a->ns1__board::endGamePoint), "xsd:int"))
				{	soap_flag_endGamePoint1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__stateArray(soap, "states", &(a->ns1__board::states), "ns1:stateArray"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__board *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__board, 0, sizeof(ns1__board), 0, soap_copy_ns1__board);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_endGamePoint1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__board::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__board);
	if (this->soap_out(soap, tag?tag:"ns1:board", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__board::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__board(soap, this, tag, type);
}

SOAP_FMAC3 ns1__board * SOAP_FMAC4 soap_get_ns1__board(struct soap *soap, ns1__board *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__board(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__board * SOAP_FMAC2 soap_instantiate_ns1__board(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__board(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__board, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__board);
		if (size)
			*size = sizeof(ns1__board);
		((ns1__board*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__board, n);
		if (size)
			*size = n * sizeof(ns1__board);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__board*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__board*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__board(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__board %p -> %p\n", q, p));
	*(ns1__board*)p = *(ns1__board*)q;
}

void ns1__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__loginResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__loginResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__board(soap, &this->ns1__loginResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loginResponse(struct soap *soap, const char *tag, int id, const ns1__loginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loginResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__board(soap, "return", -1, &(a->ns1__loginResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loginResponse * SOAP_FMAC4 soap_in_ns1__loginResponse(struct soap *soap, const char *tag, ns1__loginResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loginResponse, sizeof(ns1__loginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__loginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__loginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__board(soap, "return", &(a->ns1__loginResponse::return_), "ns1:board"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loginResponse, 0, sizeof(ns1__loginResponse), 0, soap_copy_ns1__loginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__loginResponse);
	if (this->soap_out(soap, tag?tag:"ns1:loginResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loginResponse * SOAP_FMAC4 soap_get_ns1__loginResponse(struct soap *soap, ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__loginResponse * SOAP_FMAC2 soap_instantiate_ns1__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__loginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__loginResponse);
		if (size)
			*size = sizeof(ns1__loginResponse);
		((ns1__loginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__loginResponse, n);
		if (size)
			*size = n * sizeof(ns1__loginResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__loginResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__loginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loginResponse %p -> %p\n", q, p));
	*(ns1__loginResponse*)p = *(ns1__loginResponse*)q;
}

void ns1__login::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__login::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__login(struct soap *soap, const char *tag, int id, const ns1__login *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__login), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__login(soap, tag, this, type);
}

SOAP_FMAC3 ns1__login * SOAP_FMAC4 soap_in_ns1__login(struct soap *soap, const char *tag, ns1__login *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__login, sizeof(ns1__login), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__login)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__login *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__login, 0, sizeof(ns1__login), 0, soap_copy_ns1__login);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__login);
	if (this->soap_out(soap, tag?tag:"ns1:login", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__login(soap, this, tag, type);
}

SOAP_FMAC3 ns1__login * SOAP_FMAC4 soap_get_ns1__login(struct soap *soap, ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__login * SOAP_FMAC2 soap_instantiate_ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__login);
		if (size)
			*size = sizeof(ns1__login);
		((ns1__login*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__login, n);
		if (size)
			*size = n * sizeof(ns1__login);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__login*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__login %p -> %p\n", q, p));
	*(ns1__login*)p = *(ns1__login*)q;
}

void ns1__delta::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->ns1__delta::millisecondsToNextTick);
	/* transient soap skipped */
}

void ns1__delta::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__delta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__delta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__delta(struct soap *soap, const char *tag, int id, const ns1__delta *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__delta), type))
		return soap->error;
	if (soap_out_LONG64(soap, "millisecondsToNextTick", -1, &(a->ns1__delta::millisecondsToNextTick), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__delta::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__delta(soap, tag, this, type);
}

SOAP_FMAC3 ns1__delta * SOAP_FMAC4 soap_in_ns1__delta(struct soap *soap, const char *tag, ns1__delta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__delta *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__delta, sizeof(ns1__delta), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__delta)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__delta *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_millisecondsToNextTick1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_millisecondsToNextTick1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "millisecondsToNextTick", &(a->ns1__delta::millisecondsToNextTick), "xsd:long"))
				{	soap_flag_millisecondsToNextTick1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__delta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__delta, 0, sizeof(ns1__delta), 0, soap_copy_ns1__delta);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_millisecondsToNextTick1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__delta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__delta);
	if (this->soap_out(soap, tag?tag:"ns1:delta", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__delta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__delta(soap, this, tag, type);
}

SOAP_FMAC3 ns1__delta * SOAP_FMAC4 soap_get_ns1__delta(struct soap *soap, ns1__delta *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__delta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__delta * SOAP_FMAC2 soap_instantiate_ns1__delta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__delta(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__delta, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__delta);
		if (size)
			*size = sizeof(ns1__delta);
		((ns1__delta*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__delta, n);
		if (size)
			*size = n * sizeof(ns1__delta);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__delta*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__delta*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__delta(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__delta %p -> %p\n", q, p));
	*(ns1__delta*)p = *(ns1__delta*)q;
}

void ns1__setActionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__setActionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__setActionResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__delta(soap, &this->ns1__setActionResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__setActionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setActionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setActionResponse(struct soap *soap, const char *tag, int id, const ns1__setActionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setActionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__delta(soap, "return", -1, &(a->ns1__setActionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setActionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setActionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setActionResponse * SOAP_FMAC4 soap_in_ns1__setActionResponse(struct soap *soap, const char *tag, ns1__setActionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setActionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setActionResponse, sizeof(ns1__setActionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setActionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setActionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__delta(soap, "return", &(a->ns1__setActionResponse::return_), "ns1:delta"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setActionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setActionResponse, 0, sizeof(ns1__setActionResponse), 0, soap_copy_ns1__setActionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__setActionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setActionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:setActionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__setActionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setActionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setActionResponse * SOAP_FMAC4 soap_get_ns1__setActionResponse(struct soap *soap, ns1__setActionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setActionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__setActionResponse * SOAP_FMAC2 soap_instantiate_ns1__setActionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setActionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setActionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__setActionResponse);
		if (size)
			*size = sizeof(ns1__setActionResponse);
		((ns1__setActionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__setActionResponse, n);
		if (size)
			*size = n * sizeof(ns1__setActionResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__setActionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__setActionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setActionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setActionResponse %p -> %p\n", q, p));
	*(ns1__setActionResponse*)p = *(ns1__setActionResponse*)q;
}

void ns1__setAction::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__setAction::arg0);
	this->ns1__setAction::arg1 = NULL;
	/* transient soap skipped */
}

void ns1__setAction::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__action(soap, &this->ns1__setAction::arg1);
	/* transient soap skipped */
#endif
}

int ns1__setAction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setAction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setAction(struct soap *soap, const char *tag, int id, const ns1__setAction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setAction), type))
		return soap->error;
	if (soap_out_int(soap, "arg0", -1, &(a->ns1__setAction::arg0), ""))
		return soap->error;
	if (soap_out_PointerTons1__action(soap, "arg1", -1, &(a->ns1__setAction::arg1), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setAction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setAction(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setAction * SOAP_FMAC4 soap_in_ns1__setAction(struct soap *soap, const char *tag, ns1__setAction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setAction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setAction, sizeof(ns1__setAction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setAction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setAction *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg0", &(a->ns1__setAction::arg0), "xsd:int"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__action(soap, "arg1", &(a->ns1__setAction::arg1), "ns1:action"))
				{	soap_flag_arg11--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setAction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setAction, 0, sizeof(ns1__setAction), 0, soap_copy_ns1__setAction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__setAction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setAction);
	if (this->soap_out(soap, tag?tag:"ns1:setAction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__setAction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setAction(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setAction * SOAP_FMAC4 soap_get_ns1__setAction(struct soap *soap, ns1__setAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__setAction * SOAP_FMAC2 soap_instantiate_ns1__setAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setAction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setAction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__setAction);
		if (size)
			*size = sizeof(ns1__setAction);
		((ns1__setAction*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__setAction, n);
		if (size)
			*size = n * sizeof(ns1__setAction);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__setAction*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__setAction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setAction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setAction %p -> %p\n", q, p));
	*(ns1__setAction*)p = *(ns1__setAction*)q;
}

void ns1__arrayList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__abstractList::soap_default(soap);
	this->ns1__abstractCollection::soap_default(soap);
}

void ns1__arrayList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns1__abstractList::soap_serialize(soap);
	this->ns1__abstractCollection::soap_serialize(soap);
#endif
}

int ns1__arrayList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__arrayList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__arrayList(struct soap *soap, const char *tag, int id, const ns1__arrayList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__arrayList), "ns1:arrayList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__arrayList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__arrayList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__arrayList * SOAP_FMAC4 soap_in_ns1__arrayList(struct soap *soap, const char *tag, ns1__arrayList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__arrayList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__arrayList, sizeof(ns1__arrayList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__arrayList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__arrayList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__arrayList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__arrayList, 0, sizeof(ns1__arrayList), 0, soap_copy_ns1__arrayList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__arrayList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__arrayList);
	if (this->soap_out(soap, tag?tag:"ns1:arrayList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__arrayList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__arrayList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__arrayList * SOAP_FMAC4 soap_get_ns1__arrayList(struct soap *soap, ns1__arrayList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__arrayList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__arrayList * SOAP_FMAC2 soap_instantiate_ns1__arrayList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__arrayList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__arrayList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__arrayList);
		if (size)
			*size = sizeof(ns1__arrayList);
		((ns1__arrayList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__arrayList, n);
		if (size)
			*size = n * sizeof(ns1__arrayList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__arrayList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__arrayList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__arrayList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__arrayList %p -> %p\n", q, p));
	*(ns1__arrayList*)p = *(ns1__arrayList*)q;
}

void ns1__abstractList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__abstractCollection::soap_default(soap);
}

void ns1__abstractList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns1__abstractCollection::soap_serialize(soap);
#endif
}

int ns1__abstractList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__abstractList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__abstractList(struct soap *soap, const char *tag, int id, const ns1__abstractList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__abstractList), "ns1:abstractList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__abstractList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__abstractList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__abstractList * SOAP_FMAC4 soap_in_ns1__abstractList(struct soap *soap, const char *tag, ns1__abstractList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__abstractList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__abstractList, sizeof(ns1__abstractList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__abstractList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__abstractList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__abstractList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__abstractList, 0, sizeof(ns1__abstractList), 0, soap_copy_ns1__abstractList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__abstractList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__abstractList);
	if (this->soap_out(soap, tag?tag:"ns1:abstractList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__abstractList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__abstractList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__abstractList * SOAP_FMAC4 soap_get_ns1__abstractList(struct soap *soap, ns1__abstractList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__abstractList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__abstractList * SOAP_FMAC2 soap_instantiate_ns1__abstractList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__abstractList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__abstractList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:arrayList"))
	{	cp->type = SOAP_TYPE_ns1__arrayList;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__arrayList);
			if (size)
				*size = sizeof(ns1__arrayList);
			((ns1__arrayList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__arrayList, n);
			if (size)
				*size = n * sizeof(ns1__arrayList);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__arrayList*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__arrayList*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__abstractList);
		if (size)
			*size = sizeof(ns1__abstractList);
		((ns1__abstractList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__abstractList, n);
		if (size)
			*size = n * sizeof(ns1__abstractList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__abstractList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__abstractList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__abstractList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__abstractList %p -> %p\n", q, p));
	*(ns1__abstractList*)p = *(ns1__abstractList*)q;
}

void ns1__abstractCollection::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__abstractCollection::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__abstractCollection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__abstractCollection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__abstractCollection(struct soap *soap, const char *tag, int id, const ns1__abstractCollection *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__abstractCollection), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__abstractCollection::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__abstractCollection(soap, tag, this, type);
}

SOAP_FMAC3 ns1__abstractCollection * SOAP_FMAC4 soap_in_ns1__abstractCollection(struct soap *soap, const char *tag, ns1__abstractCollection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__abstractCollection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__abstractCollection, sizeof(ns1__abstractCollection), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__abstractCollection)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__abstractCollection *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__abstractCollection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__abstractCollection, 0, sizeof(ns1__abstractCollection), 0, soap_copy_ns1__abstractCollection);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__abstractCollection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__abstractCollection);
	if (this->soap_out(soap, tag?tag:"ns1:abstractCollection", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__abstractCollection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__abstractCollection(soap, this, tag, type);
}

SOAP_FMAC3 ns1__abstractCollection * SOAP_FMAC4 soap_get_ns1__abstractCollection(struct soap *soap, ns1__abstractCollection *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__abstractCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__abstractCollection * SOAP_FMAC2 soap_instantiate_ns1__abstractCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__abstractCollection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__abstractCollection, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:abstractList"))
	{	cp->type = SOAP_TYPE_ns1__abstractList;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__abstractList);
			if (size)
				*size = sizeof(ns1__abstractList);
			((ns1__abstractList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__abstractList, n);
			if (size)
				*size = n * sizeof(ns1__abstractList);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__abstractList*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__abstractList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:arrayList"))
	{	cp->type = SOAP_TYPE_ns1__arrayList;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__arrayList);
			if (size)
				*size = sizeof(ns1__arrayList);
			((ns1__arrayList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__arrayList, n);
			if (size)
				*size = n * sizeof(ns1__arrayList);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__arrayList*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__arrayList*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__abstractCollection);
		if (size)
			*size = sizeof(ns1__abstractCollection);
		((ns1__abstractCollection*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__abstractCollection, n);
		if (size)
			*size = n * sizeof(ns1__abstractCollection);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__abstractCollection*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__abstractCollection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__abstractCollection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__abstractCollection %p -> %p\n", q, p));
	*(ns1__abstractCollection*)p = *(ns1__abstractCollection*)q;
}

void ns1__base::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__base::x);
	soap_default_int(soap, &this->ns1__base::y);
	/* transient soap skipped */
}

void ns1__base::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__base::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__base(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__base(struct soap *soap, const char *tag, int id, const ns1__base *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__base), type))
		return soap->error;
	if (soap_out_int(soap, "x", -1, &(a->ns1__base::x), ""))
		return soap->error;
	if (soap_out_int(soap, "y", -1, &(a->ns1__base::y), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__base::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__base(soap, tag, this, type);
}

SOAP_FMAC3 ns1__base * SOAP_FMAC4 soap_in_ns1__base(struct soap *soap, const char *tag, ns1__base *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__base *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__base, sizeof(ns1__base), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__base)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__base *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_x1 = 1;
	size_t soap_flag_y1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_x1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "x", &(a->ns1__base::x), "xsd:int"))
				{	soap_flag_x1--;
					continue;
				}
			if (soap_flag_y1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "y", &(a->ns1__base::y), "xsd:int"))
				{	soap_flag_y1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__base *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__base, 0, sizeof(ns1__base), 0, soap_copy_ns1__base);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_x1 > 0 || soap_flag_y1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__base::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__base);
	if (this->soap_out(soap, tag?tag:"ns1:base", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__base::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__base(soap, this, tag, type);
}

SOAP_FMAC3 ns1__base * SOAP_FMAC4 soap_get_ns1__base(struct soap *soap, ns1__base *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__base(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__base * SOAP_FMAC2 soap_instantiate_ns1__base(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__base(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__base, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__base);
		if (size)
			*size = sizeof(ns1__base);
		((ns1__base*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__base, n);
		if (size)
			*size = n * sizeof(ns1__base);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__base*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__base*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__base(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__base %p -> %p\n", q, p));
	*(ns1__base*)p = *(ns1__base*)q;
}

void ns1__player::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__player::base = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__bullet(soap, &this->ns1__player::bullets);
	this->ns1__player::name = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__unit(soap, &this->ns1__player::units);
	/* transient soap skipped */
}

void ns1__player::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__base(soap, &this->ns1__player::base);
	soap_serialize_std__vectorTemplateOfPointerTons1__bullet(soap, &this->ns1__player::bullets);
	soap_serialize_PointerTostd__string(soap, &this->ns1__player::name);
	soap_serialize_std__vectorTemplateOfPointerTons1__unit(soap, &this->ns1__player::units);
	/* transient soap skipped */
#endif
}

int ns1__player::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__player(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__player(struct soap *soap, const char *tag, int id, const ns1__player *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__player), type))
		return soap->error;
	if (soap_out_PointerTons1__base(soap, "base", -1, &(a->ns1__player::base), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__bullet(soap, "bullets", -1, &(a->ns1__player::bullets), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__player::name), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__unit(soap, "units", -1, &(a->ns1__player::units), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__player::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__player(soap, tag, this, type);
}

SOAP_FMAC3 ns1__player * SOAP_FMAC4 soap_in_ns1__player(struct soap *soap, const char *tag, ns1__player *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__player *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__player, sizeof(ns1__player), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__player)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__player *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__base(soap, "base", &(a->ns1__player::base), "ns1:base"))
				{	soap_flag_base1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__bullet(soap, "bullets", &(a->ns1__player::bullets), "ns1:bullet"))
					continue;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__player::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__unit(soap, "units", &(a->ns1__player::units), "ns1:unit"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__player *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__player, 0, sizeof(ns1__player), 0, soap_copy_ns1__player);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__player::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__player);
	if (this->soap_out(soap, tag?tag:"ns1:player", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__player::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__player(soap, this, tag, type);
}

SOAP_FMAC3 ns1__player * SOAP_FMAC4 soap_get_ns1__player(struct soap *soap, ns1__player *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__player(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__player * SOAP_FMAC2 soap_instantiate_ns1__player(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__player(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__player, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__player);
		if (size)
			*size = sizeof(ns1__player);
		((ns1__player*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__player, n);
		if (size)
			*size = n * sizeof(ns1__player);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__player*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__player*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__player(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__player %p -> %p\n", q, p));
	*(ns1__player*)p = *(ns1__player*)q;
}

void ns1__unit::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__unit::action = NULL;
	this->ns1__unit::direction = NULL;
	soap_default_int(soap, &this->ns1__unit::id);
	soap_default_int(soap, &this->ns1__unit::x);
	soap_default_int(soap, &this->ns1__unit::y);
	/* transient soap skipped */
}

void ns1__unit::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__action(soap, &this->ns1__unit::action);
	soap_serialize_PointerTons1__direction(soap, &this->ns1__unit::direction);
	/* transient soap skipped */
#endif
}

int ns1__unit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__unit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unit(struct soap *soap, const char *tag, int id, const ns1__unit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unit), type))
		return soap->error;
	if (soap_out_PointerTons1__action(soap, "action", -1, &(a->ns1__unit::action), ""))
		return soap->error;
	if (soap_out_PointerTons1__direction(soap, "direction", -1, &(a->ns1__unit::direction), ""))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns1__unit::id), ""))
		return soap->error;
	if (soap_out_int(soap, "x", -1, &(a->ns1__unit::x), ""))
		return soap->error;
	if (soap_out_int(soap, "y", -1, &(a->ns1__unit::y), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__unit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__unit(soap, tag, this, type);
}

SOAP_FMAC3 ns1__unit * SOAP_FMAC4 soap_in_ns1__unit(struct soap *soap, const char *tag, ns1__unit *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__unit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unit, sizeof(ns1__unit), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__unit)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__unit *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_action1 = 1;
	size_t soap_flag_direction1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_x1 = 1;
	size_t soap_flag_y1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_action1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__action(soap, "action", &(a->ns1__unit::action), "ns1:action"))
				{	soap_flag_action1--;
					continue;
				}
			if (soap_flag_direction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__direction(soap, "direction", &(a->ns1__unit::direction), "ns1:direction"))
				{	soap_flag_direction1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns1__unit::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_x1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "x", &(a->ns1__unit::x), "xsd:int"))
				{	soap_flag_x1--;
					continue;
				}
			if (soap_flag_y1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "y", &(a->ns1__unit::y), "xsd:int"))
				{	soap_flag_y1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__unit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unit, 0, sizeof(ns1__unit), 0, soap_copy_ns1__unit);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_x1 > 0 || soap_flag_y1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__unit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__unit);
	if (this->soap_out(soap, tag?tag:"ns1:unit", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__unit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__unit(soap, this, tag, type);
}

SOAP_FMAC3 ns1__unit * SOAP_FMAC4 soap_get_ns1__unit(struct soap *soap, ns1__unit *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__unit * SOAP_FMAC2 soap_instantiate_ns1__unit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__unit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__unit);
		if (size)
			*size = sizeof(ns1__unit);
		((ns1__unit*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__unit, n);
		if (size)
			*size = n * sizeof(ns1__unit);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__unit*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__unit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__unit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__unit %p -> %p\n", q, p));
	*(ns1__unit*)p = *(ns1__unit*)q;
}

void ns1__bullet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__bullet::direction = NULL;
	soap_default_int(soap, &this->ns1__bullet::id);
	soap_default_int(soap, &this->ns1__bullet::x);
	soap_default_int(soap, &this->ns1__bullet::y);
	/* transient soap skipped */
}

void ns1__bullet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__direction(soap, &this->ns1__bullet::direction);
	/* transient soap skipped */
#endif
}

int ns1__bullet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__bullet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bullet(struct soap *soap, const char *tag, int id, const ns1__bullet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bullet), type))
		return soap->error;
	if (soap_out_PointerTons1__direction(soap, "direction", -1, &(a->ns1__bullet::direction), ""))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns1__bullet::id), ""))
		return soap->error;
	if (soap_out_int(soap, "x", -1, &(a->ns1__bullet::x), ""))
		return soap->error;
	if (soap_out_int(soap, "y", -1, &(a->ns1__bullet::y), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__bullet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__bullet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__bullet * SOAP_FMAC4 soap_in_ns1__bullet(struct soap *soap, const char *tag, ns1__bullet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__bullet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bullet, sizeof(ns1__bullet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__bullet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__bullet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_direction1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_x1 = 1;
	size_t soap_flag_y1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_direction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__direction(soap, "direction", &(a->ns1__bullet::direction), "ns1:direction"))
				{	soap_flag_direction1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns1__bullet::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_x1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "x", &(a->ns1__bullet::x), "xsd:int"))
				{	soap_flag_x1--;
					continue;
				}
			if (soap_flag_y1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "y", &(a->ns1__bullet::y), "xsd:int"))
				{	soap_flag_y1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__bullet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__bullet, 0, sizeof(ns1__bullet), 0, soap_copy_ns1__bullet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_x1 > 0 || soap_flag_y1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__bullet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__bullet);
	if (this->soap_out(soap, tag?tag:"ns1:bullet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__bullet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__bullet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__bullet * SOAP_FMAC4 soap_get_ns1__bullet(struct soap *soap, ns1__bullet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bullet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__bullet * SOAP_FMAC2 soap_instantiate_ns1__bullet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bullet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bullet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__bullet);
		if (size)
			*size = sizeof(ns1__bullet);
		((ns1__bullet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__bullet, n);
		if (size)
			*size = n * sizeof(ns1__bullet);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__bullet*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__bullet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bullet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__bullet %p -> %p\n", q, p));
	*(ns1__bullet*)p = *(ns1__bullet*)q;
}

void ns1__unitEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__unitEvent::bullet = NULL;
	soap_default_int(soap, &this->ns1__unitEvent::tickTime);
	this->ns1__unitEvent::unit = NULL;
	/* transient soap skipped */
}

void ns1__unitEvent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__bullet(soap, &this->ns1__unitEvent::bullet);
	soap_serialize_PointerTons1__unit(soap, &this->ns1__unitEvent::unit);
	/* transient soap skipped */
#endif
}

int ns1__unitEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__unitEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unitEvent(struct soap *soap, const char *tag, int id, const ns1__unitEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unitEvent), type))
		return soap->error;
	if (soap_out_PointerTons1__bullet(soap, "bullet", -1, &(a->ns1__unitEvent::bullet), ""))
		return soap->error;
	if (soap_out_int(soap, "tickTime", -1, &(a->ns1__unitEvent::tickTime), ""))
		return soap->error;
	if (soap_out_PointerTons1__unit(soap, "unit", -1, &(a->ns1__unitEvent::unit), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__unitEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__unitEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__unitEvent * SOAP_FMAC4 soap_in_ns1__unitEvent(struct soap *soap, const char *tag, ns1__unitEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__unitEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unitEvent, sizeof(ns1__unitEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__unitEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__unitEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_bullet1 = 1;
	size_t soap_flag_tickTime1 = 1;
	size_t soap_flag_unit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bullet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__bullet(soap, "bullet", &(a->ns1__unitEvent::bullet), "ns1:bullet"))
				{	soap_flag_bullet1--;
					continue;
				}
			if (soap_flag_tickTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tickTime", &(a->ns1__unitEvent::tickTime), "xsd:int"))
				{	soap_flag_tickTime1--;
					continue;
				}
			if (soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__unit(soap, "unit", &(a->ns1__unitEvent::unit), "ns1:unit"))
				{	soap_flag_unit1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__unitEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unitEvent, 0, sizeof(ns1__unitEvent), 0, soap_copy_ns1__unitEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tickTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__unitEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__unitEvent);
	if (this->soap_out(soap, tag?tag:"ns1:unitEvent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__unitEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__unitEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__unitEvent * SOAP_FMAC4 soap_get_ns1__unitEvent(struct soap *soap, ns1__unitEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unitEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__unitEvent * SOAP_FMAC2 soap_instantiate_ns1__unitEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unitEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__unitEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__unitEvent);
		if (size)
			*size = sizeof(ns1__unitEvent);
		((ns1__unitEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__unitEvent, n);
		if (size)
			*size = n * sizeof(ns1__unitEvent);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__unitEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__unitEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__unitEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__unitEvent %p -> %p\n", q, p));
	*(ns1__unitEvent*)p = *(ns1__unitEvent*)q;
}

void ns1__point::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__point::x);
	soap_default_int(soap, &this->ns1__point::y);
	/* transient soap skipped */
}

void ns1__point::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__point::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__point(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__point(struct soap *soap, const char *tag, int id, const ns1__point *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__point), type))
		return soap->error;
	if (soap_out_int(soap, "x", -1, &(a->ns1__point::x), ""))
		return soap->error;
	if (soap_out_int(soap, "y", -1, &(a->ns1__point::y), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__point::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__point(soap, tag, this, type);
}

SOAP_FMAC3 ns1__point * SOAP_FMAC4 soap_in_ns1__point(struct soap *soap, const char *tag, ns1__point *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__point *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__point, sizeof(ns1__point), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__point)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__point *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_x1 = 1;
	size_t soap_flag_y1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_x1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "x", &(a->ns1__point::x), "xsd:int"))
				{	soap_flag_x1--;
					continue;
				}
			if (soap_flag_y1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "y", &(a->ns1__point::y), "xsd:int"))
				{	soap_flag_y1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__point *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__point, 0, sizeof(ns1__point), 0, soap_copy_ns1__point);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_x1 > 0 || soap_flag_y1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__point::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__point);
	if (this->soap_out(soap, tag?tag:"ns1:point", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__point::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__point(soap, this, tag, type);
}

SOAP_FMAC3 ns1__point * SOAP_FMAC4 soap_get_ns1__point(struct soap *soap, ns1__point *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__point(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__point * SOAP_FMAC2 soap_instantiate_ns1__point(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__point(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__point, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__point);
		if (size)
			*size = sizeof(ns1__point);
		((ns1__point*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__point, n);
		if (size)
			*size = n * sizeof(ns1__point);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__point*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__point*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__point(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__point %p -> %p\n", q, p));
	*(ns1__point*)p = *(ns1__point*)q;
}

void ns1__blockEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__blockEvent::newState = NULL;
	this->ns1__blockEvent::point = NULL;
	/* transient soap skipped */
}

void ns1__blockEvent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__state(soap, &this->ns1__blockEvent::newState);
	soap_serialize_PointerTons1__point(soap, &this->ns1__blockEvent::point);
	/* transient soap skipped */
#endif
}

int ns1__blockEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__blockEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__blockEvent(struct soap *soap, const char *tag, int id, const ns1__blockEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__blockEvent), type))
		return soap->error;
	if (soap_out_PointerTons1__state(soap, "newState", -1, &(a->ns1__blockEvent::newState), ""))
		return soap->error;
	if (soap_out_PointerTons1__point(soap, "point", -1, &(a->ns1__blockEvent::point), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__blockEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__blockEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__blockEvent * SOAP_FMAC4 soap_in_ns1__blockEvent(struct soap *soap, const char *tag, ns1__blockEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__blockEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__blockEvent, sizeof(ns1__blockEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__blockEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__blockEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_newState1 = 1;
	size_t soap_flag_point1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_newState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__state(soap, "newState", &(a->ns1__blockEvent::newState), "ns1:state"))
				{	soap_flag_newState1--;
					continue;
				}
			if (soap_flag_point1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__point(soap, "point", &(a->ns1__blockEvent::point), "ns1:point"))
				{	soap_flag_point1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__blockEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__blockEvent, 0, sizeof(ns1__blockEvent), 0, soap_copy_ns1__blockEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__blockEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__blockEvent);
	if (this->soap_out(soap, tag?tag:"ns1:blockEvent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__blockEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__blockEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__blockEvent * SOAP_FMAC4 soap_get_ns1__blockEvent(struct soap *soap, ns1__blockEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__blockEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__blockEvent * SOAP_FMAC2 soap_instantiate_ns1__blockEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__blockEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__blockEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__blockEvent);
		if (size)
			*size = sizeof(ns1__blockEvent);
		((ns1__blockEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__blockEvent, n);
		if (size)
			*size = n * sizeof(ns1__blockEvent);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__blockEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__blockEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__blockEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__blockEvent %p -> %p\n", q, p));
	*(ns1__blockEvent*)p = *(ns1__blockEvent*)q;
}

void ns1__events::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__blockEvent(soap, &this->ns1__events::blockEvents);
	soap_default_std__vectorTemplateOfPointerTons1__unitEvent(soap, &this->ns1__events::unitEvents);
	/* transient soap skipped */
}

void ns1__events::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__blockEvent(soap, &this->ns1__events::blockEvents);
	soap_serialize_std__vectorTemplateOfPointerTons1__unitEvent(soap, &this->ns1__events::unitEvents);
	/* transient soap skipped */
#endif
}

int ns1__events::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__events(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__events(struct soap *soap, const char *tag, int id, const ns1__events *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__events), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__blockEvent(soap, "blockEvents", -1, &(a->ns1__events::blockEvents), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__unitEvent(soap, "unitEvents", -1, &(a->ns1__events::unitEvents), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__events::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__events(soap, tag, this, type);
}

SOAP_FMAC3 ns1__events * SOAP_FMAC4 soap_in_ns1__events(struct soap *soap, const char *tag, ns1__events *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__events *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__events, sizeof(ns1__events), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__events)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__events *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__blockEvent(soap, "blockEvents", &(a->ns1__events::blockEvents), "ns1:blockEvent"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__unitEvent(soap, "unitEvents", &(a->ns1__events::unitEvents), "ns1:unitEvent"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__events *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__events, 0, sizeof(ns1__events), 0, soap_copy_ns1__events);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__events::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__events);
	if (this->soap_out(soap, tag?tag:"ns1:events", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__events::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__events(soap, this, tag, type);
}

SOAP_FMAC3 ns1__events * SOAP_FMAC4 soap_get_ns1__events(struct soap *soap, ns1__events *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__events(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__events * SOAP_FMAC2 soap_instantiate_ns1__events(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__events(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__events, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__events);
		if (size)
			*size = sizeof(ns1__events);
		((ns1__events*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__events, n);
		if (size)
			*size = n * sizeof(ns1__events);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__events*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__events*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__events(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__events %p -> %p\n", q, p));
	*(ns1__events*)p = *(ns1__events*)q;
}

void ns1__game::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__game::currentTick);
	this->ns1__game::events = NULL;
	soap_default_LONG64(soap, &this->ns1__game::millisecondsToNextTick);
	this->ns1__game::nextTickTime = NULL;
	this->ns1__game::playerName = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__player(soap, &this->ns1__game::players);
	/* transient soap skipped */
}

void ns1__game::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__events(soap, &this->ns1__game::events);
	soap_serialize_PointerTotime(soap, &this->ns1__game::nextTickTime);
	soap_serialize_PointerTostd__string(soap, &this->ns1__game::playerName);
	soap_serialize_std__vectorTemplateOfPointerTons1__player(soap, &this->ns1__game::players);
	/* transient soap skipped */
#endif
}

int ns1__game::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__game(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__game(struct soap *soap, const char *tag, int id, const ns1__game *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__game), type))
		return soap->error;
	if (soap_out_int(soap, "currentTick", -1, &(a->ns1__game::currentTick), ""))
		return soap->error;
	if (soap_out_PointerTons1__events(soap, "events", -1, &(a->ns1__game::events), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "millisecondsToNextTick", -1, &(a->ns1__game::millisecondsToNextTick), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "nextTickTime", -1, &(a->ns1__game::nextTickTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "playerName", -1, &(a->ns1__game::playerName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__player(soap, "players", -1, &(a->ns1__game::players), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__game::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__game(soap, tag, this, type);
}

SOAP_FMAC3 ns1__game * SOAP_FMAC4 soap_in_ns1__game(struct soap *soap, const char *tag, ns1__game *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__game *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__game, sizeof(ns1__game), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__game)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__game *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_currentTick1 = 1;
	size_t soap_flag_events1 = 1;
	size_t soap_flag_millisecondsToNextTick1 = 1;
	size_t soap_flag_nextTickTime1 = 1;
	size_t soap_flag_playerName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentTick1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "currentTick", &(a->ns1__game::currentTick), "xsd:int"))
				{	soap_flag_currentTick1--;
					continue;
				}
			if (soap_flag_events1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__events(soap, "events", &(a->ns1__game::events), "ns1:events"))
				{	soap_flag_events1--;
					continue;
				}
			if (soap_flag_millisecondsToNextTick1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "millisecondsToNextTick", &(a->ns1__game::millisecondsToNextTick), "xsd:long"))
				{	soap_flag_millisecondsToNextTick1--;
					continue;
				}
			if (soap_flag_nextTickTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "nextTickTime", &(a->ns1__game::nextTickTime), "xsd:dateTime"))
				{	soap_flag_nextTickTime1--;
					continue;
				}
			if (soap_flag_playerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "playerName", &(a->ns1__game::playerName), "xsd:string"))
				{	soap_flag_playerName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__player(soap, "players", &(a->ns1__game::players), "ns1:player"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__game *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__game, 0, sizeof(ns1__game), 0, soap_copy_ns1__game);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentTick1 > 0 || soap_flag_millisecondsToNextTick1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__game::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__game);
	if (this->soap_out(soap, tag?tag:"ns1:game", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__game::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__game(soap, this, tag, type);
}

SOAP_FMAC3 ns1__game * SOAP_FMAC4 soap_get_ns1__game(struct soap *soap, ns1__game *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__game(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__game * SOAP_FMAC2 soap_instantiate_ns1__game(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__game(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__game, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__game);
		if (size)
			*size = sizeof(ns1__game);
		((ns1__game*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__game, n);
		if (size)
			*size = n * sizeof(ns1__game);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__game*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__game*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__game(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__game %p -> %p\n", q, p));
	*(ns1__game*)p = *(ns1__game*)q;
}

void ns1__getStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getStatusResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getStatusResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__game(soap, &this->ns1__getStatusResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStatusResponse(struct soap *soap, const char *tag, int id, const ns1__getStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__game(soap, "return", -1, &(a->ns1__getStatusResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getStatusResponse * SOAP_FMAC4 soap_in_ns1__getStatusResponse(struct soap *soap, const char *tag, ns1__getStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStatusResponse, sizeof(ns1__getStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__game(soap, "return", &(a->ns1__getStatusResponse::return_), "ns1:game"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStatusResponse, 0, sizeof(ns1__getStatusResponse), 0, soap_copy_ns1__getStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getStatusResponse * SOAP_FMAC4 soap_get_ns1__getStatusResponse(struct soap *soap, ns1__getStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__getStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStatusResponse);
		if (size)
			*size = sizeof(ns1__getStatusResponse);
		((ns1__getStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getStatusResponse, n);
		if (size)
			*size = n * sizeof(ns1__getStatusResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getStatusResponse %p -> %p\n", q, p));
	*(ns1__getStatusResponse*)p = *(ns1__getStatusResponse*)q;
}

void ns1__getStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__getStatus::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__getStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStatus(struct soap *soap, const char *tag, int id, const ns1__getStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStatus), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getStatus * SOAP_FMAC4 soap_in_ns1__getStatus(struct soap *soap, const char *tag, ns1__getStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStatus, sizeof(ns1__getStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStatus, 0, sizeof(ns1__getStatus), 0, soap_copy_ns1__getStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getStatus);
	if (this->soap_out(soap, tag?tag:"ns1:getStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getStatus * SOAP_FMAC4 soap_get_ns1__getStatus(struct soap *soap, ns1__getStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getStatus * SOAP_FMAC2 soap_instantiate_ns1__getStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStatus);
		if (size)
			*size = sizeof(ns1__getStatus);
		((ns1__getStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getStatus, n);
		if (size)
			*size = n * sizeof(ns1__getStatus);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getStatus %p -> %p\n", q, p));
	*(ns1__getStatus*)p = *(ns1__getStatus*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setActions(struct soap *soap, struct __ns1__setActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setActions_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setActions(struct soap *soap, const struct __ns1__setActions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setActions(soap, &a->ns1__setActions_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setActions(struct soap *soap, const char *tag, int id, const struct __ns1__setActions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__setActions(soap, "ns1:setActions", -1, &a->ns1__setActions_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setActions * SOAP_FMAC4 soap_in___ns1__setActions(struct soap *soap, const char *tag, struct __ns1__setActions *a, const char *type)
{
	size_t soap_flag_ns1__setActions_ = 1;
	short soap_flag;
	a = (struct __ns1__setActions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setActions, sizeof(struct __ns1__setActions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setActions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setActions_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setActions(soap, "ns1:setActions", &a->ns1__setActions_, "ns1:setActions"))
				{	soap_flag_ns1__setActions_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setActions(struct soap *soap, const struct __ns1__setActions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setActions(soap, tag?tag:"-ns1:setActions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setActions * SOAP_FMAC4 soap_get___ns1__setActions(struct soap *soap, struct __ns1__setActions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setActions * SOAP_FMAC2 soap_instantiate___ns1__setActions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setActions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setActions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setActions);
		if (size)
			*size = sizeof(struct __ns1__setActions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setActions, n);
		if (size)
			*size = n * sizeof(struct __ns1__setActions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setActions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setActions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setActions %p -> %p\n", q, p));
	*(struct __ns1__setActions*)p = *(struct __ns1__setActions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__login(struct soap *soap, struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__login_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__login(struct soap *soap, const struct __ns1__login *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__login(soap, &a->ns1__login_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__login(struct soap *soap, const char *tag, int id, const struct __ns1__login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__login(soap, "ns1:login", -1, &a->ns1__login_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_in___ns1__login(struct soap *soap, const char *tag, struct __ns1__login *a, const char *type)
{
	size_t soap_flag_ns1__login_ = 1;
	short soap_flag;
	a = (struct __ns1__login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__login, sizeof(struct __ns1__login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__login_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__login(soap, "ns1:login", &a->ns1__login_, "ns1:login"))
				{	soap_flag_ns1__login_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__login(struct soap *soap, const struct __ns1__login *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__login(soap, tag?tag:"-ns1:login", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_get___ns1__login(struct soap *soap, struct __ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__login * SOAP_FMAC2 soap_instantiate___ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__login);
		if (size)
			*size = sizeof(struct __ns1__login);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__login, n);
		if (size)
			*size = n * sizeof(struct __ns1__login);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__login %p -> %p\n", q, p));
	*(struct __ns1__login*)p = *(struct __ns1__login*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setAction(struct soap *soap, struct __ns1__setAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setAction_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setAction(struct soap *soap, const struct __ns1__setAction *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setAction(soap, &a->ns1__setAction_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setAction(struct soap *soap, const char *tag, int id, const struct __ns1__setAction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__setAction(soap, "ns1:setAction", -1, &a->ns1__setAction_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAction * SOAP_FMAC4 soap_in___ns1__setAction(struct soap *soap, const char *tag, struct __ns1__setAction *a, const char *type)
{
	size_t soap_flag_ns1__setAction_ = 1;
	short soap_flag;
	a = (struct __ns1__setAction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setAction, sizeof(struct __ns1__setAction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setAction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setAction_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setAction(soap, "ns1:setAction", &a->ns1__setAction_, "ns1:setAction"))
				{	soap_flag_ns1__setAction_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setAction(struct soap *soap, const struct __ns1__setAction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setAction(soap, tag?tag:"-ns1:setAction", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAction * SOAP_FMAC4 soap_get___ns1__setAction(struct soap *soap, struct __ns1__setAction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setAction * SOAP_FMAC2 soap_instantiate___ns1__setAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setAction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setAction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setAction);
		if (size)
			*size = sizeof(struct __ns1__setAction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__setAction, n);
		if (size)
			*size = n * sizeof(struct __ns1__setAction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__setAction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setAction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setAction %p -> %p\n", q, p));
	*(struct __ns1__setAction*)p = *(struct __ns1__setAction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStatus(struct soap *soap, struct __ns1__getStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStatus_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStatus(struct soap *soap, const struct __ns1__getStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getStatus(soap, &a->ns1__getStatus_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStatus(struct soap *soap, const char *tag, int id, const struct __ns1__getStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getStatus(soap, "ns1:getStatus", -1, &a->ns1__getStatus_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStatus * SOAP_FMAC4 soap_in___ns1__getStatus(struct soap *soap, const char *tag, struct __ns1__getStatus *a, const char *type)
{
	size_t soap_flag_ns1__getStatus_ = 1;
	short soap_flag;
	a = (struct __ns1__getStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStatus, sizeof(struct __ns1__getStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStatus_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getStatus(soap, "ns1:getStatus", &a->ns1__getStatus_, "ns1:getStatus"))
				{	soap_flag_ns1__getStatus_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStatus(struct soap *soap, const struct __ns1__getStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getStatus(soap, tag?tag:"-ns1:getStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStatus * SOAP_FMAC4 soap_get___ns1__getStatus(struct soap *soap, struct __ns1__getStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getStatus * SOAP_FMAC2 soap_instantiate___ns1__getStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getStatus);
		if (size)
			*size = sizeof(struct __ns1__getStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getStatus, n);
		if (size)
			*size = n * sizeof(struct __ns1__getStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getStatus %p -> %p\n", q, p));
	*(struct __ns1__getStatus*)p = *(struct __ns1__getStatus*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->ns1__EndOfGameException_ = NULL;
	a->ns1__NoBlameException_ = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__EndOfGameException(soap, &a->ns1__EndOfGameException_);
	soap_serialize_PointerTons1__NoBlameException(soap, &a->ns1__NoBlameException_);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_out_PointerTons1__EndOfGameException(soap, "ns1:EndOfGameException", -1, &a->ns1__EndOfGameException_, ""))
		return soap->error;
	if (soap_out_PointerTons1__NoBlameException(soap, "ns1:NoBlameException", -1, &a->ns1__NoBlameException_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns1__EndOfGameException_ = 1;
	size_t soap_flag_ns1__NoBlameException_ = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndOfGameException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EndOfGameException(soap, "ns1:EndOfGameException", &a->ns1__EndOfGameException_, "ns1:EndOfGameException"))
				{	soap_flag_ns1__EndOfGameException_--;
					continue;
				}
			if (soap_flag_ns1__NoBlameException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NoBlameException(soap, "ns1:NoBlameException", &a->ns1__NoBlameException_, "ns1:NoBlameException"))
				{	soap_flag_ns1__NoBlameException_--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setActionsResponse(struct soap *soap, ns1__setActionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setActionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setActionsResponse(struct soap *soap, const char *tag, int id, ns1__setActionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setActionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setActionsResponse ** SOAP_FMAC4 soap_in_PointerTons1__setActionsResponse(struct soap *soap, const char *tag, ns1__setActionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setActionsResponse **)soap_malloc(soap, sizeof(ns1__setActionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setActionsResponse *)soap_instantiate_ns1__setActionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setActionsResponse ** p = (ns1__setActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setActionsResponse, sizeof(ns1__setActionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setActionsResponse(struct soap *soap, ns1__setActionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setActionsResponse);
	if (soap_out_PointerTons1__setActionsResponse(soap, tag?tag:"ns1:setActionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__setActionsResponse ** SOAP_FMAC4 soap_get_PointerTons1__setActionsResponse(struct soap *soap, ns1__setActionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setActions(struct soap *soap, ns1__setActions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setActions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setActions(struct soap *soap, const char *tag, int id, ns1__setActions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setActions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setActions ** SOAP_FMAC4 soap_in_PointerTons1__setActions(struct soap *soap, const char *tag, ns1__setActions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setActions **)soap_malloc(soap, sizeof(ns1__setActions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setActions *)soap_instantiate_ns1__setActions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setActions ** p = (ns1__setActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setActions, sizeof(ns1__setActions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setActions(struct soap *soap, ns1__setActions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setActions);
	if (soap_out_PointerTons1__setActions(soap, tag?tag:"ns1:setActions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__setActions ** SOAP_FMAC4 soap_get_PointerTons1__setActions(struct soap *soap, ns1__setActions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loginResponse(struct soap *soap, ns1__loginResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__loginResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loginResponse(struct soap *soap, const char *tag, int id, ns1__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__loginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__loginResponse ** SOAP_FMAC4 soap_in_PointerTons1__loginResponse(struct soap *soap, const char *tag, ns1__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__loginResponse **)soap_malloc(soap, sizeof(ns1__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__loginResponse *)soap_instantiate_ns1__loginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__loginResponse ** p = (ns1__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginResponse, sizeof(ns1__loginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loginResponse(struct soap *soap, ns1__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__loginResponse);
	if (soap_out_PointerTons1__loginResponse(soap, tag?tag:"ns1:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__loginResponse ** SOAP_FMAC4 soap_get_PointerTons1__loginResponse(struct soap *soap, ns1__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__login(struct soap *soap, ns1__login *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__login(struct soap *soap, const char *tag, int id, ns1__login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__login);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__login ** SOAP_FMAC4 soap_in_PointerTons1__login(struct soap *soap, const char *tag, ns1__login **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__login **)soap_malloc(soap, sizeof(ns1__login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__login *)soap_instantiate_ns1__login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__login ** p = (ns1__login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__login, sizeof(ns1__login), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__login(struct soap *soap, ns1__login *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__login);
	if (soap_out_PointerTons1__login(soap, tag?tag:"ns1:login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__login ** SOAP_FMAC4 soap_get_PointerTons1__login(struct soap *soap, ns1__login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setActionResponse(struct soap *soap, ns1__setActionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setActionResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setActionResponse(struct soap *soap, const char *tag, int id, ns1__setActionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setActionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setActionResponse ** SOAP_FMAC4 soap_in_PointerTons1__setActionResponse(struct soap *soap, const char *tag, ns1__setActionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setActionResponse **)soap_malloc(soap, sizeof(ns1__setActionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setActionResponse *)soap_instantiate_ns1__setActionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setActionResponse ** p = (ns1__setActionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setActionResponse, sizeof(ns1__setActionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setActionResponse(struct soap *soap, ns1__setActionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setActionResponse);
	if (soap_out_PointerTons1__setActionResponse(soap, tag?tag:"ns1:setActionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__setActionResponse ** SOAP_FMAC4 soap_get_PointerTons1__setActionResponse(struct soap *soap, ns1__setActionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setActionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setAction(struct soap *soap, ns1__setAction *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setAction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setAction(struct soap *soap, const char *tag, int id, ns1__setAction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setAction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setAction ** SOAP_FMAC4 soap_in_PointerTons1__setAction(struct soap *soap, const char *tag, ns1__setAction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setAction **)soap_malloc(soap, sizeof(ns1__setAction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setAction *)soap_instantiate_ns1__setAction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setAction ** p = (ns1__setAction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setAction, sizeof(ns1__setAction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setAction(struct soap *soap, ns1__setAction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setAction);
	if (soap_out_PointerTons1__setAction(soap, tag?tag:"ns1:setAction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__setAction ** SOAP_FMAC4 soap_get_PointerTons1__setAction(struct soap *soap, ns1__setAction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getStatusResponse(struct soap *soap, ns1__getStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getStatusResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getStatusResponse(struct soap *soap, const char *tag, int id, ns1__getStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getStatusResponse ** SOAP_FMAC4 soap_in_PointerTons1__getStatusResponse(struct soap *soap, const char *tag, ns1__getStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getStatusResponse **)soap_malloc(soap, sizeof(ns1__getStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getStatusResponse *)soap_instantiate_ns1__getStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getStatusResponse ** p = (ns1__getStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getStatusResponse, sizeof(ns1__getStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getStatusResponse(struct soap *soap, ns1__getStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getStatusResponse);
	if (soap_out_PointerTons1__getStatusResponse(soap, tag?tag:"ns1:getStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getStatusResponse ** SOAP_FMAC4 soap_get_PointerTons1__getStatusResponse(struct soap *soap, ns1__getStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getStatus(struct soap *soap, ns1__getStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getStatus(struct soap *soap, const char *tag, int id, ns1__getStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getStatus ** SOAP_FMAC4 soap_in_PointerTons1__getStatus(struct soap *soap, const char *tag, ns1__getStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getStatus **)soap_malloc(soap, sizeof(ns1__getStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getStatus *)soap_instantiate_ns1__getStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getStatus ** p = (ns1__getStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getStatus, sizeof(ns1__getStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getStatus(struct soap *soap, ns1__getStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getStatus);
	if (soap_out_PointerTons1__getStatus(soap, tag?tag:"ns1:getStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getStatus ** SOAP_FMAC4 soap_get_PointerTons1__getStatus(struct soap *soap, ns1__getStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NoBlameException(struct soap *soap, ns1__NoBlameException *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NoBlameException))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NoBlameException(struct soap *soap, const char *tag, int id, ns1__NoBlameException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NoBlameException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__NoBlameException ** SOAP_FMAC4 soap_in_PointerTons1__NoBlameException(struct soap *soap, const char *tag, ns1__NoBlameException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NoBlameException **)soap_malloc(soap, sizeof(ns1__NoBlameException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NoBlameException *)soap_instantiate_ns1__NoBlameException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__NoBlameException ** p = (ns1__NoBlameException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoBlameException, sizeof(ns1__NoBlameException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NoBlameException(struct soap *soap, ns1__NoBlameException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NoBlameException);
	if (soap_out_PointerTons1__NoBlameException(soap, tag?tag:"ns1:NoBlameException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NoBlameException ** SOAP_FMAC4 soap_get_PointerTons1__NoBlameException(struct soap *soap, ns1__NoBlameException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NoBlameException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EndOfGameException(struct soap *soap, ns1__EndOfGameException *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EndOfGameException))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EndOfGameException(struct soap *soap, const char *tag, int id, ns1__EndOfGameException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EndOfGameException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EndOfGameException ** SOAP_FMAC4 soap_in_PointerTons1__EndOfGameException(struct soap *soap, const char *tag, ns1__EndOfGameException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EndOfGameException **)soap_malloc(soap, sizeof(ns1__EndOfGameException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EndOfGameException *)soap_instantiate_ns1__EndOfGameException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__EndOfGameException ** p = (ns1__EndOfGameException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EndOfGameException, sizeof(ns1__EndOfGameException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EndOfGameException(struct soap *soap, ns1__EndOfGameException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EndOfGameException);
	if (soap_out_PointerTons1__EndOfGameException(soap, tag?tag:"ns1:EndOfGameException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EndOfGameException ** SOAP_FMAC4 soap_get_PointerTons1__EndOfGameException(struct soap *soap, ns1__EndOfGameException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EndOfGameException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__stateArray(struct soap *soap, ns1__stateArray *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__stateArray))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__stateArray(struct soap *soap, const char *tag, int id, ns1__stateArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__stateArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__stateArray ** SOAP_FMAC4 soap_in_PointerTons1__stateArray(struct soap *soap, const char *tag, ns1__stateArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__stateArray **)soap_malloc(soap, sizeof(ns1__stateArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__stateArray *)soap_instantiate_ns1__stateArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__stateArray ** p = (ns1__stateArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__stateArray, sizeof(ns1__stateArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__stateArray(struct soap *soap, ns1__stateArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__stateArray);
	if (soap_out_PointerTons1__stateArray(soap, tag?tag:"ns1:stateArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__stateArray ** SOAP_FMAC4 soap_get_PointerTons1__stateArray(struct soap *soap, ns1__stateArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__stateArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__board(struct soap *soap, ns1__board *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__board))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__board(struct soap *soap, const char *tag, int id, ns1__board *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__board);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__board ** SOAP_FMAC4 soap_in_PointerTons1__board(struct soap *soap, const char *tag, ns1__board **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__board **)soap_malloc(soap, sizeof(ns1__board *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__board *)soap_instantiate_ns1__board(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__board ** p = (ns1__board **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__board, sizeof(ns1__board), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__board(struct soap *soap, ns1__board *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__board);
	if (soap_out_PointerTons1__board(soap, tag?tag:"ns1:board", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__board ** SOAP_FMAC4 soap_get_PointerTons1__board(struct soap *soap, ns1__board **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__board(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__delta(struct soap *soap, ns1__delta *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__delta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__delta(struct soap *soap, const char *tag, int id, ns1__delta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__delta);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__delta ** SOAP_FMAC4 soap_in_PointerTons1__delta(struct soap *soap, const char *tag, ns1__delta **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__delta **)soap_malloc(soap, sizeof(ns1__delta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__delta *)soap_instantiate_ns1__delta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__delta ** p = (ns1__delta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__delta, sizeof(ns1__delta), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__delta(struct soap *soap, ns1__delta *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__delta);
	if (soap_out_PointerTons1__delta(soap, tag?tag:"ns1:delta", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__delta ** SOAP_FMAC4 soap_get_PointerTons1__delta(struct soap *soap, ns1__delta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__delta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__base(struct soap *soap, ns1__base *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__base))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__base(struct soap *soap, const char *tag, int id, ns1__base *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__base);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__base ** SOAP_FMAC4 soap_in_PointerTons1__base(struct soap *soap, const char *tag, ns1__base **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__base **)soap_malloc(soap, sizeof(ns1__base *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__base *)soap_instantiate_ns1__base(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__base ** p = (ns1__base **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__base, sizeof(ns1__base), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__base(struct soap *soap, ns1__base *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__base);
	if (soap_out_PointerTons1__base(soap, tag?tag:"ns1:base", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__base ** SOAP_FMAC4 soap_get_PointerTons1__base(struct soap *soap, ns1__base **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__base(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__action(struct soap *soap, enum ns1__action *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__action);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__action(struct soap *soap, const char *tag, int id, enum ns1__action *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__action);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__action(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__action ** SOAP_FMAC4 soap_in_PointerTons1__action(struct soap *soap, const char *tag, enum ns1__action **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__action **)soap_malloc(soap, sizeof(enum ns1__action *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__action(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__action **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__action, sizeof(enum ns1__action), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__action(struct soap *soap, enum ns1__action *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__action);
	if (soap_out_PointerTons1__action(soap, tag?tag:"ns1:action", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__action ** SOAP_FMAC4 soap_get_PointerTons1__action(struct soap *soap, enum ns1__action **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__action(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__direction(struct soap *soap, enum ns1__direction *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__direction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__direction(struct soap *soap, const char *tag, int id, enum ns1__direction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__direction);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__direction(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__direction ** SOAP_FMAC4 soap_in_PointerTons1__direction(struct soap *soap, const char *tag, enum ns1__direction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__direction **)soap_malloc(soap, sizeof(enum ns1__direction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__direction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__direction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__direction, sizeof(enum ns1__direction), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__direction(struct soap *soap, enum ns1__direction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__direction);
	if (soap_out_PointerTons1__direction(soap, tag?tag:"ns1:direction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__direction ** SOAP_FMAC4 soap_get_PointerTons1__direction(struct soap *soap, enum ns1__direction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__direction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__unit(struct soap *soap, ns1__unit *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__unit))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__unit(struct soap *soap, const char *tag, int id, ns1__unit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__unit);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__unit ** SOAP_FMAC4 soap_in_PointerTons1__unit(struct soap *soap, const char *tag, ns1__unit **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__unit **)soap_malloc(soap, sizeof(ns1__unit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__unit *)soap_instantiate_ns1__unit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__unit ** p = (ns1__unit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__unit, sizeof(ns1__unit), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__unit(struct soap *soap, ns1__unit *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__unit);
	if (soap_out_PointerTons1__unit(soap, tag?tag:"ns1:unit", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__unit ** SOAP_FMAC4 soap_get_PointerTons1__unit(struct soap *soap, ns1__unit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__unit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__bullet(struct soap *soap, ns1__bullet *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__bullet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__bullet(struct soap *soap, const char *tag, int id, ns1__bullet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__bullet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__bullet ** SOAP_FMAC4 soap_in_PointerTons1__bullet(struct soap *soap, const char *tag, ns1__bullet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__bullet **)soap_malloc(soap, sizeof(ns1__bullet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__bullet *)soap_instantiate_ns1__bullet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__bullet ** p = (ns1__bullet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__bullet, sizeof(ns1__bullet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__bullet(struct soap *soap, ns1__bullet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__bullet);
	if (soap_out_PointerTons1__bullet(soap, tag?tag:"ns1:bullet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__bullet ** SOAP_FMAC4 soap_get_PointerTons1__bullet(struct soap *soap, ns1__bullet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__bullet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__point(struct soap *soap, ns1__point *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__point))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__point(struct soap *soap, const char *tag, int id, ns1__point *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__point);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__point ** SOAP_FMAC4 soap_in_PointerTons1__point(struct soap *soap, const char *tag, ns1__point **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__point **)soap_malloc(soap, sizeof(ns1__point *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__point *)soap_instantiate_ns1__point(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__point ** p = (ns1__point **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__point, sizeof(ns1__point), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__point(struct soap *soap, ns1__point *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__point);
	if (soap_out_PointerTons1__point(soap, tag?tag:"ns1:point", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__point ** SOAP_FMAC4 soap_get_PointerTons1__point(struct soap *soap, ns1__point **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__point(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__state(struct soap *soap, enum ns1__state *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__state);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__state(struct soap *soap, const char *tag, int id, enum ns1__state *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__state);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__state(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__state ** SOAP_FMAC4 soap_in_PointerTons1__state(struct soap *soap, const char *tag, enum ns1__state **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__state **)soap_malloc(soap, sizeof(enum ns1__state *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__state(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__state **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__state, sizeof(enum ns1__state), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__state(struct soap *soap, enum ns1__state *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__state);
	if (soap_out_PointerTons1__state(soap, tag?tag:"ns1:state", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__state ** SOAP_FMAC4 soap_get_PointerTons1__state(struct soap *soap, enum ns1__state **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__state(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__unitEvent(struct soap *soap, ns1__unitEvent *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__unitEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__unitEvent(struct soap *soap, const char *tag, int id, ns1__unitEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__unitEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__unitEvent ** SOAP_FMAC4 soap_in_PointerTons1__unitEvent(struct soap *soap, const char *tag, ns1__unitEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__unitEvent **)soap_malloc(soap, sizeof(ns1__unitEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__unitEvent *)soap_instantiate_ns1__unitEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__unitEvent ** p = (ns1__unitEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__unitEvent, sizeof(ns1__unitEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__unitEvent(struct soap *soap, ns1__unitEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__unitEvent);
	if (soap_out_PointerTons1__unitEvent(soap, tag?tag:"ns1:unitEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__unitEvent ** SOAP_FMAC4 soap_get_PointerTons1__unitEvent(struct soap *soap, ns1__unitEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__unitEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__blockEvent(struct soap *soap, ns1__blockEvent *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__blockEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__blockEvent(struct soap *soap, const char *tag, int id, ns1__blockEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__blockEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__blockEvent ** SOAP_FMAC4 soap_in_PointerTons1__blockEvent(struct soap *soap, const char *tag, ns1__blockEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__blockEvent **)soap_malloc(soap, sizeof(ns1__blockEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__blockEvent *)soap_instantiate_ns1__blockEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__blockEvent ** p = (ns1__blockEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__blockEvent, sizeof(ns1__blockEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__blockEvent(struct soap *soap, ns1__blockEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__blockEvent);
	if (soap_out_PointerTons1__blockEvent(soap, tag?tag:"ns1:blockEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__blockEvent ** SOAP_FMAC4 soap_get_PointerTons1__blockEvent(struct soap *soap, ns1__blockEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__blockEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__player(struct soap *soap, ns1__player *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__player))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__player(struct soap *soap, const char *tag, int id, ns1__player *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__player);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__player ** SOAP_FMAC4 soap_in_PointerTons1__player(struct soap *soap, const char *tag, ns1__player **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__player **)soap_malloc(soap, sizeof(ns1__player *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__player *)soap_instantiate_ns1__player(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__player ** p = (ns1__player **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__player, sizeof(ns1__player), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__player(struct soap *soap, ns1__player *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__player);
	if (soap_out_PointerTons1__player(soap, tag?tag:"ns1:player", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__player ** SOAP_FMAC4 soap_get_PointerTons1__player(struct soap *soap, ns1__player **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__player(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__events(struct soap *soap, ns1__events *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__events))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__events(struct soap *soap, const char *tag, int id, ns1__events *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__events);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__events ** SOAP_FMAC4 soap_in_PointerTons1__events(struct soap *soap, const char *tag, ns1__events **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__events **)soap_malloc(soap, sizeof(ns1__events *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__events *)soap_instantiate_ns1__events(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__events ** p = (ns1__events **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__events, sizeof(ns1__events), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__events(struct soap *soap, ns1__events *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__events);
	if (soap_out_PointerTons1__events(soap, tag?tag:"ns1:events", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__events ** SOAP_FMAC4 soap_get_PointerTons1__events(struct soap *soap, ns1__events **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__events(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__game(struct soap *soap, ns1__game *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__game))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__game(struct soap *soap, const char *tag, int id, ns1__game *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__game);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__game ** SOAP_FMAC4 soap_in_PointerTons1__game(struct soap *soap, const char *tag, ns1__game **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__game **)soap_malloc(soap, sizeof(ns1__game *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__game *)soap_instantiate_ns1__game(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__game ** p = (ns1__game **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__game, sizeof(ns1__game), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__game(struct soap *soap, ns1__game *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__game);
	if (soap_out_PointerTons1__game(soap, tag?tag:"ns1:game", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__game ** SOAP_FMAC4 soap_get_PointerTons1__game(struct soap *soap, ns1__game **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__game(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__state(struct soap *soap, std::vector<enum ns1__state >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__state(struct soap *soap, const std::vector<enum ns1__state >*a)
{
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__state(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__state >*a, const char *type)
{
	for (std::vector<enum ns1__state >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__state(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__state >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__state(struct soap *soap, const char *tag, std::vector<enum ns1__state >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	enum ns1__state n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_ns1__state(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__state, SOAP_TYPE_std__vectorTemplateOfns1__state, sizeof(enum ns1__state), 0))
				break;
			if (!soap_in_ns1__state(soap, tag, NULL, "ns1:state"))
				break;
		}
		else if (!soap_in_ns1__state(soap, tag, &n, "ns1:state"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfns1__state(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns1__state > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__state(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__state(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns1__state, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns1__state >);
		if (size)
			*size = sizeof(std::vector<enum ns1__state >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<enum ns1__state >, n);
		if (size)
			*size = n * sizeof(std::vector<enum ns1__state >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<enum ns1__state >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns1__state(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns1__state > %p -> %p\n", q, p));
	*(std::vector<enum ns1__state >*)p = *(std::vector<enum ns1__state >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__stateArray(struct soap *soap, std::vector<ns1__stateArray * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__stateArray(struct soap *soap, const std::vector<ns1__stateArray * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__stateArray * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__stateArray(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__stateArray(struct soap *soap, const char *tag, int id, const std::vector<ns1__stateArray * >*a, const char *type)
{
	for (std::vector<ns1__stateArray * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__stateArray(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__stateArray * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__stateArray(struct soap *soap, const char *tag, std::vector<ns1__stateArray * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__stateArray *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__stateArray, SOAP_TYPE_std__vectorTemplateOfPointerTons1__stateArray, sizeof(ns1__stateArray), 1))
				break;
			if (!soap_in_PointerTons1__stateArray(soap, tag, NULL, "ns1:stateArray"))
				break;
		}
		else if (!soap_in_PointerTons1__stateArray(soap, tag, &n, "ns1:stateArray"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__stateArray(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__stateArray * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__stateArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__stateArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__stateArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__stateArray * >);
		if (size)
			*size = sizeof(std::vector<ns1__stateArray * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__stateArray * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__stateArray * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__stateArray * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__stateArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__stateArray * > %p -> %p\n", q, p));
	*(std::vector<ns1__stateArray * >*)p = *(std::vector<ns1__stateArray * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__unit(struct soap *soap, std::vector<ns1__unit * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__unit(struct soap *soap, const std::vector<ns1__unit * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__unit * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__unit(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__unit(struct soap *soap, const char *tag, int id, const std::vector<ns1__unit * >*a, const char *type)
{
	for (std::vector<ns1__unit * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__unit(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__unit * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__unit(struct soap *soap, const char *tag, std::vector<ns1__unit * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__unit *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__unit, SOAP_TYPE_std__vectorTemplateOfPointerTons1__unit, sizeof(ns1__unit), 1))
				break;
			if (!soap_in_PointerTons1__unit(soap, tag, NULL, "ns1:unit"))
				break;
		}
		else if (!soap_in_PointerTons1__unit(soap, tag, &n, "ns1:unit"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__unit(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__unit * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__unit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__unit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__unit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__unit * >);
		if (size)
			*size = sizeof(std::vector<ns1__unit * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__unit * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__unit * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__unit * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__unit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__unit * > %p -> %p\n", q, p));
	*(std::vector<ns1__unit * >*)p = *(std::vector<ns1__unit * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__bullet(struct soap *soap, std::vector<ns1__bullet * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__bullet(struct soap *soap, const std::vector<ns1__bullet * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__bullet * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__bullet(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__bullet(struct soap *soap, const char *tag, int id, const std::vector<ns1__bullet * >*a, const char *type)
{
	for (std::vector<ns1__bullet * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__bullet(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__bullet * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__bullet(struct soap *soap, const char *tag, std::vector<ns1__bullet * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__bullet *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__bullet, SOAP_TYPE_std__vectorTemplateOfPointerTons1__bullet, sizeof(ns1__bullet), 1))
				break;
			if (!soap_in_PointerTons1__bullet(soap, tag, NULL, "ns1:bullet"))
				break;
		}
		else if (!soap_in_PointerTons1__bullet(soap, tag, &n, "ns1:bullet"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__bullet(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__bullet * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__bullet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__bullet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__bullet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__bullet * >);
		if (size)
			*size = sizeof(std::vector<ns1__bullet * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__bullet * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__bullet * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__bullet * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__bullet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__bullet * > %p -> %p\n", q, p));
	*(std::vector<ns1__bullet * >*)p = *(std::vector<ns1__bullet * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__unitEvent(struct soap *soap, std::vector<ns1__unitEvent * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__unitEvent(struct soap *soap, const std::vector<ns1__unitEvent * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__unitEvent * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__unitEvent(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__unitEvent(struct soap *soap, const char *tag, int id, const std::vector<ns1__unitEvent * >*a, const char *type)
{
	for (std::vector<ns1__unitEvent * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__unitEvent(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__unitEvent * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__unitEvent(struct soap *soap, const char *tag, std::vector<ns1__unitEvent * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__unitEvent *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__unitEvent, SOAP_TYPE_std__vectorTemplateOfPointerTons1__unitEvent, sizeof(ns1__unitEvent), 1))
				break;
			if (!soap_in_PointerTons1__unitEvent(soap, tag, NULL, "ns1:unitEvent"))
				break;
		}
		else if (!soap_in_PointerTons1__unitEvent(soap, tag, &n, "ns1:unitEvent"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__unitEvent(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__unitEvent * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__unitEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__unitEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__unitEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__unitEvent * >);
		if (size)
			*size = sizeof(std::vector<ns1__unitEvent * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__unitEvent * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__unitEvent * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__unitEvent * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__unitEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__unitEvent * > %p -> %p\n", q, p));
	*(std::vector<ns1__unitEvent * >*)p = *(std::vector<ns1__unitEvent * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__blockEvent(struct soap *soap, std::vector<ns1__blockEvent * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__blockEvent(struct soap *soap, const std::vector<ns1__blockEvent * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__blockEvent * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__blockEvent(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__blockEvent(struct soap *soap, const char *tag, int id, const std::vector<ns1__blockEvent * >*a, const char *type)
{
	for (std::vector<ns1__blockEvent * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__blockEvent(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__blockEvent * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__blockEvent(struct soap *soap, const char *tag, std::vector<ns1__blockEvent * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__blockEvent *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__blockEvent, SOAP_TYPE_std__vectorTemplateOfPointerTons1__blockEvent, sizeof(ns1__blockEvent), 1))
				break;
			if (!soap_in_PointerTons1__blockEvent(soap, tag, NULL, "ns1:blockEvent"))
				break;
		}
		else if (!soap_in_PointerTons1__blockEvent(soap, tag, &n, "ns1:blockEvent"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__blockEvent(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__blockEvent * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__blockEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__blockEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__blockEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__blockEvent * >);
		if (size)
			*size = sizeof(std::vector<ns1__blockEvent * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__blockEvent * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__blockEvent * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__blockEvent * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__blockEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__blockEvent * > %p -> %p\n", q, p));
	*(std::vector<ns1__blockEvent * >*)p = *(std::vector<ns1__blockEvent * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__player(struct soap *soap, std::vector<ns1__player * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__player(struct soap *soap, const std::vector<ns1__player * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__player * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__player(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__player(struct soap *soap, const char *tag, int id, const std::vector<ns1__player * >*a, const char *type)
{
	for (std::vector<ns1__player * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__player(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__player * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__player(struct soap *soap, const char *tag, std::vector<ns1__player * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__player *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__player, SOAP_TYPE_std__vectorTemplateOfPointerTons1__player, sizeof(ns1__player), 1))
				break;
			if (!soap_in_PointerTons1__player(soap, tag, NULL, "ns1:player"))
				break;
		}
		else if (!soap_in_PointerTons1__player(soap, tag, &n, "ns1:player"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__player(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__player * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__player(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__player(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__player, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__player * >);
		if (size)
			*size = sizeof(std::vector<ns1__player * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__player * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__player * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__player * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__player(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__player * > %p -> %p\n", q, p));
	*(std::vector<ns1__player * >*)p = *(std::vector<ns1__player * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
